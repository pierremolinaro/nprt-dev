#---------------------------------------------------------------------------*#                                                                           *#   S Y N T A X                                                             *#                                                                           *#---------------------------------------------------------------------------*syntax oa_parser :import lexique oa_scanner in "oa_scanner.gLexique" ;import semantics oa_semantics in "oa_semantics.ggs" ;nonterminal <axiome> ;rule <axiome>:  @M_processor outProcessorMap := [@M_processor emptyMap] ;  @M_network outNetworkMap := [@M_network emptyMap] ;  @M_messages outMessagesMap := [@M_messages emptyMap] ;  @M_tasks outTaskMap := [@M_tasks emptyMap] ;  $system$ ;  repeat  while    $processor$ ;    @lstring processorName ;    $identifier$ ? processorName ;    @luint step ;    select     step := [@luint new !1 !here] ;    or      $scalingfactor$ ;      $literal_integer$ ? step ;      if [step uint] == 0 then        error step : "the step value must be > 0" ;      end if ;    end select ;    [!?outProcessorMap insertKey !processorName !step] ;    $;$ ;  while    @bool network ;    select      $can$ ;      network := true ;    or      $van$ ;      network := false ;    end select ;    $network$ ;    @lstring networkName ;    $identifier$ ? networkName ;    @luint factor ;    select     factor := [@luint new !1 !here] ;    or      $scalingfactor$ ;      $literal_integer$ ? factor ;      if [factor uint] == 0 then        error factor : "the factor value must be > 0" ;      end if ;    end select ;    [!?outNetworkMap insertKey !networkName !network !factor] ;    $;$ ;  while    $task$ ;    @lstring taskName ;    $identifier$ ? taskName ;    $priority$ ;    @luint taskPriority ;    $literal_integer$ ? taskPriority ;    $duration$ ;    @luint taskDurationMin ;    $literal_integer$ ? taskDurationMin ;    $..$ ;    @luint taskDurationMax ;    $literal_integer$ ? taskDurationMax ;    @luint taskOffset ;    @bool explicitOffset ;    select      $offset$ ;      $literal_integer$ ? taskOffset ;      explicitOffset := true ;    or      taskOffset := [@luint new !0 ! here] ;      explicitOffset := false ;    end select ;    @luint taskDeadline ;    select      $deadline$ ;      $literal_integer$ ? taskDeadline ;    or      taskDeadline := [@luint new !4294967295 !here] ;    end select ;    @AC_task taskKind ;    @luint taskProcessorIndex ;    @luint taskPeriod ;    select      $period$ ;      $literal_integer$ ? taskPeriod ;      $processor$ ;      @lstring taskProcessorName ;      $identifier$ ? taskProcessorName ;      [outProcessorMap searchKeyGetIndex !taskProcessorName ?taskProcessorIndex ?*] ;      taskKind := [@C_independantTask new] ;    or      $on$ ;      if explicitOffset then        error here : "A dependant task cannot have an offset" ;      end if ;      select        $task$ ;        @lstring masterTaskName ;        $identifier$ ? masterTaskName ;        @luint every ;        select          every := [@luint new !1 !here] ;        or          $every$ ;          $literal_integer$ ? every ;        end select ;        @luint masterTaskIndex ;        [outTaskMap searchKeyGetIndex !masterTaskName ?masterTaskIndex ?* ?* ?* ?* ?* ?taskProcessorIndex ?taskPeriod ?*] ;        taskKind := [@C_taskDependsFromTask new !masterTaskIndex !every] ;      or        $message$ ;        @lstring masterMessageName ;        $identifier$ ? masterMessageName ;        @luint masterMessageIndex ;        [outMessagesMap searchKeyGetIndex !masterMessageName ?masterMessageIndex ?* ?* ?* ?* ?* ?* ?taskPeriod ?*] ;        $processor$ ;        @lstring taskProcessorName ;        $identifier$ ? taskProcessorName ;        @luint every ;        select          every := [@luint new !1 !here] ;        or          $every$ ;          $literal_integer$ ? every ;        end select ;        [outProcessorMap searchKeyGetIndex !taskProcessorName ?taskProcessorIndex ?*] ;        taskKind := [@C_taskDependsFromMessage new !masterMessageIndex !every] ;      end select ;    end select ;    [!?outTaskMap insertKey !taskName !taskPriority                                        !taskOffset                                        !taskDeadline                                        !taskDurationMin                                        !taskDurationMax                                        !taskProcessorIndex                                        !taskPeriod                                        !taskKind] ;    $;$ ;  while    @luint messageClass ;    select      $standard$ ;      messageClass := [@luint new !0 !here] ;      $message$ ;    or      $extended$ ;      messageClass := [@luint new !1 !here] ;      $message$ ;    or      $message$ ;      messageClass := [@luint new !2 !here] ;    end select ;    @lstring messageName ;    $identifier$ ? messageName ;    $network$ ;    @lstring networkName ;    $identifier$ ? networkName ;    @luint networkIndex ;    @bool CANnetwork ;    [outNetworkMap searchKeyGetIndex !networkName ?networkIndex ?CANnetwork ?*] ;    if CANnetwork & ([messageClass uint] == 2) then      error messageClass : "a CAN message must be either standard either extended" ;    elsif (not CANnetwork) & ([messageClass uint] != 2) then      error messageClass : "a VAN message cannot be standard or extended" ;    end if ;    $length$ ;    @luint bytesCount ;    $literal_integer$ ? bytesCount ;    if CANnetwork & ([bytesCount uint] > 8) then      error bytesCount : "CAN message length must be <= 8 bytes" ;    elsif (not CANnetwork) & ([bytesCount uint] > 28) then      error bytesCount : "VAN message must be <= 28 bytes" ;    end if ;    $priority$ ;    @luint priority ;    $literal_integer$ ? priority ;    @luint offset ;    @bool explicitOffset ;    select      $offset$ ;      $literal_integer$ ? offset ;      explicitOffset := true ;    or      offset := [@luint new !0 !here] ;      explicitOffset := false ;    end select ;    @luint deadline ;    select      $deadline$ ;      $literal_integer$ ? deadline ;    or      deadline := [@luint new !4294967295 !here] ;    end select ;    @AC_canMessage messageKind ;    @luint period ;    select      $period$ ;      $literal_integer$ ? period ;      messageKind := [@C_canIndependantMessage new] ;    or      $on$ ;      if explicitOffset then        error here : "A dependant task cannot have an offset" ;      end if ;      select        $message$ ;        @lstring name ;        $identifier$ ? name ;        @luint messageIndex ;        [outMessagesMap searchKeyGetIndex !name ?messageIndex ?* ?* ?* ?* ?* ?* ?period ?*] ;        messageKind := [@C_canMessageFromMessage new !messageIndex] ;      or        $task$ ;        @lstring taskName ;        $identifier$ ? taskName ;        @luint taskIndex ;        [outTaskMap searchKeyGetIndex !taskName ?taskIndex ?* ?* ?* ?* ?* ?* ?period ?*] ;        messageKind := [@C_canMessageFromTask new !taskIndex] ;      end select ;    end select ;    [!?outMessagesMap insertKey !messageName         !messageClass !networkIndex !bytesCount !priority !offset !deadline !period !messageKind] ;    $;$ ;          end repeat ;  $end$ ;  performComputations    !?outProcessorMap    !?outNetworkMap    !?outMessagesMap    !?outTaskMap  ;
#  @string d [stringWithCurrentDateTime] ;
#  log d ;
#  @lstring z [new !"azerty" !here] ;
#  @uint lg := [z length] ;
#  log lg ;
#--- Testing environment variables
#  @string ev := [@string stringWithEnvironmentVariable !"azerty"] ;#  log ev ;#  ev := [@string stringWithEnvironmentVariableOrEmpty !"azerty"] ;#  log ev ;#  ev := [@string stringWithEnvironmentVariable !"PATH"] ;#  log ev ;end rule ;end syntax ;#---------------------------------------------------------------------------*