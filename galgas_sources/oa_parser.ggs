#---------------------------------------------------------------------------*#                                                                           *#   L E X I Q U E                                                           *#                                                                           *#---------------------------------------------------------------------------*lexique oa_scanner :header "galgas/F_LexicalActions.h" ;@lstring identifierString ;@luint ulongValue ;style identifier -> "Identifiers" ;style keyWords -> "Key words" ;style delimitors -> "Delimitors" ;style integer_csts -> "Integer constants" ;# -------------------------- identifier or key word --------------------# keywords can be written in lower# for identifiers, case is significant$identifier$ ! identifierString error message "an identifier" style identifier ;list keyWordList error message "the '" . * . "' key word" style keyWords : "system", "end", "task", "standard", "extended", "message", "length", "priority", "period", "offset", "on", "deadline", "duration", "processor", "can", "van", "network", "scalingfactor", "every" ;rule 'a'->'z' | 'A'->'Z' :  repeat    enterCharacterIntoString (identifierString, *) ;  while 'a'->'z' | 'A'->'Z' | '_' | '0'->'9' :  end repeat ;  send search identifierString in keyWordList default $identifier$ ;end rule ;#--- Delimitors  list delimitorsList error message "the ''" . * . "'' delimitor" style delimitors :    ",", ";", ".." ;  rule list delimitorsList ;#------------------------------- Decimal positive number ------------------$literal_integer$ ! ulongValue error message "a decimal number" style integer_csts ;message decimalNumberTooLarge : "decimal number too large" ;message internalError : "internal error" ;rule '0'->'9' :  enterDigitIntoUlong (ulongValue, *) error decimalNumberTooLarge, internalError ;  repeat  while '0'->'9' :    enterDigitIntoUlong (ulongValue, *) error decimalNumberTooLarge, internalError ;  while '_' :  end repeat ;  send $literal_integer$ ;end rule ;#--- separators  rule '\1' -> ' ' :  end rule ;# ------------------------------------ Comment ----------------------------message incorrectEndOfComment : "incorrect end of comment" ;rule '#' :  repeat  while '\1' ->'\t' | '\v'-> '\255' :  end repeat ;  select  when '\n' :  default    error incorrectEndOfComment ;  end select ;end rule ;end lexique ;#---------------------------------------------------------------------------*#                                                                           *#   S E M A N T I C S                                                       *#                                                                           *#---------------------------------------------------------------------------*semantics oa_semantics :  map @M_processor    insert insertKey error message "the processor '" . * . "' has been already declared" ;    search searchKey error message "the processor '" . * . "' is not declared" ;    @luint mStep ;  end map ;  map @M_network    insert insertKey error message "the processor '" . * . "' has been already declared" ;    search searchKey error message "the processor '" . * . "' is not declared" ;    @bool mCANnetwork ;    @luint mScalingFactor ;  end map ;  abstract class @AC_canMessage    include header ;  end class ;    class @C_canIndependantMessage extends @AC_canMessage   end class ;    class @C_canMessageFromMessage extends @AC_canMessage     @luint mMessageIndex ;  end class ;    class @C_canMessageFromTask extends @AC_canMessage     @luint mTaskIndex ;  end class ;      map @M_messages    insert insertKey error message "the CAN message '" . * . "' has been already declared" ;    search searchKey error message "the CAN message '" . * . "' is not declared" ;    @luint mClass ; # 0 : standard can, 1 : extented can, 2 : van    @luint mNetworkIndex ;    @luint mBytesCount ;    @luint mPriority ;    @luint mOffset ;    @luint mDeadline ;    @luint mPeriod ;    @AC_canMessage mMessageKind ;  end map ;    abstract class @AC_task    include header ;  end class ;    class @C_independantTask extends @AC_task   end class ;    class @C_taskDependsFromTask extends @AC_task     @luint mTask ;    @luint mEvery ; end class ;    class @C_taskDependsFromMessage extends @AC_task     @luint mMessage ;    @luint mEvery ;  end class ;    map @M_tasks    insert insertKey error message "the task '" . * . "' has been already declared" ;    search searchKey error message "the task '" . * . "' is not declared" ;    @luint mPriority ;    @luint mOffset ;    @luint mDeadline ;    @luint mDurationMin ;    @luint mDurationMax ;    @luint mProcessor ;    @luint mPeriod ;    @AC_task mTaskKind ;  end map ;action performComputations  ?!@M_processor outProcessorMap  ?!@M_network outNetworkMap  ?!@M_messages outMessagesMap  ?!@M_tasks outTaskMap;end semantics ;#---------------------------------------------------------------------------*#                                                                           *#   S Y N T A X                                                             *#                                                                           *#---------------------------------------------------------------------------*syntax oa_parser :import lexique oa_scanner ;import semantics oa_semantics ;rule <axiome> ;rule <axiome>:  @M_processor outProcessorMap := [@M_processor empty] ;  @M_network outNetworkMap := [@M_network empty] ;  @M_messages outMessagesMap := [@M_messages empty] ;  @M_tasks outTaskMap := [@M_tasks empty] ;  $system$ ;  repeat  while    $processor$ ;    @lstring processorName ;    $identifier$ ? processorName ;    @luint step ;    select     step := [@luint new !1 !here] ;    or      $scalingfactor$ ;      $literal_integer$ ? step ;      if [step value] == 0 then        error step : "the step value must be > 0" ;      end if ;    end select ;    [!?outProcessorMap insertKey !processorName !step] ;    $;$ ;  while    @bool network ;    select      $can$ ;      network := true ;    or      $van$ ;      network := false ;    end select ;    $network$ ;    @lstring networkName ;    $identifier$ ? networkName ;    @luint factor ;    select     factor := [@luint new !1 !here] ;    or      $scalingfactor$ ;      $literal_integer$ ? factor ;      if [factor value] == 0 then        error factor : "the factor value must be > 0" ;      end if ;    end select ;    [!?outNetworkMap insertKey !networkName !network !factor] ;    $;$ ;  while    $task$ ;    @lstring taskName ;    $identifier$ ? taskName ;    $priority$ ;    @luint taskPriority ;    $literal_integer$ ? taskPriority ;    $duration$ ;    @luint taskDurationMin ;    $literal_integer$ ? taskDurationMin ;    $..$ ;    @luint taskDurationMax ;    $literal_integer$ ? taskDurationMax ;    @luint taskOffset ;    @bool explicitOffset ;    select      $offset$ ;      $literal_integer$ ? taskOffset ;      explicitOffset := true ;    or      taskOffset := [@luint new !0 ! here] ;      explicitOffset := false ;    end select ;    @luint taskDeadline ;    select      $deadline$ ;      $literal_integer$ ? taskDeadline ;    or      taskDeadline := [@luint new !4294967295 !here] ;    end select ;    @AC_task taskKind ;    @luint taskProcessorIndex ;    @luint taskPeriod ;    select      $period$ ;      $literal_integer$ ? taskPeriod ;      $processor$ ;      @lstring taskProcessorName ;      $identifier$ ? taskProcessorName ;      [!?outProcessorMap searchKeyGetIndex !taskProcessorName ?taskProcessorIndex ?*] ;      taskKind := [@C_independantTask new] ;    or      $on$ ;      if explicitOffset then        error here : "A dependant task cannot have an offset" ;      end if ;      select        $task$ ;        @lstring masterTaskName ;        $identifier$ ? masterTaskName ;        @luint every ;        select          every := [@luint new !1 !here] ;        or          $every$ ;          $literal_integer$ ? every ;        end select ;        @luint masterTaskIndex ;        [!?outTaskMap searchKeyGetIndex !masterTaskName ?masterTaskIndex ?* ?* ?* ?* ?* ?taskProcessorIndex ?taskPeriod ?*] ;        taskKind := [@C_taskDependsFromTask new !masterTaskIndex !every] ;      or        $message$ ;        @lstring masterMessageName ;        $identifier$ ? masterMessageName ;        @luint masterMessageIndex ;        [!?outMessagesMap searchKeyGetIndex !masterMessageName ?masterMessageIndex ?* ?* ?* ?* ?* ?* ?taskPeriod ?*] ;        $processor$ ;        @lstring taskProcessorName ;        $identifier$ ? taskProcessorName ;        @luint every ;        select          every := [@luint new !1 !here] ;        or          $every$ ;          $literal_integer$ ? every ;        end select ;        [!?outProcessorMap searchKeyGetIndex !taskProcessorName ?taskProcessorIndex ?*] ;        taskKind := [@C_taskDependsFromMessage new !masterMessageIndex !every] ;      end select ;    end select ;    [!?outTaskMap insertKey !taskName !taskPriority                                        !taskOffset                                        !taskDeadline                                        !taskDurationMin                                        !taskDurationMax                                        !taskProcessorIndex                                        !taskPeriod                                        !taskKind] ;    $;$ ;  while    @luint messageClass ;    select      $standard$ ;      messageClass := [@luint new !0 !here] ;      $message$ ;    or      $extended$ ;      messageClass := [@luint new !1 !here] ;      $message$ ;    or      $message$ ;      messageClass := [@luint new !2 !here] ;    end select ;    @lstring messageName ;    $identifier$ ? messageName ;    $network$ ;    @lstring networkName ;    $identifier$ ? networkName ;    @luint networkIndex ;    @bool CANnetwork ;    [!?outNetworkMap searchKeyGetIndex !networkName ?networkIndex ?CANnetwork ?*] ;    if CANnetwork & ([messageClass value] == 2) then      error messageClass : "a CAN message must be either standard either extended" ;    elsif (not CANnetwork) & ([messageClass value] != 2) then      error messageClass : "a VAN message cannot be standard or extended" ;    end if ;    $length$ ;    @luint bytesCount ;    $literal_integer$ ? bytesCount ;    if CANnetwork & ([bytesCount value] > 8) then      error bytesCount : "CAN message length must be <= 8 bytes" ;    elsif (not CANnetwork) & ([bytesCount value] > 28) then      error bytesCount : "VAN message must be <= 28 bytes" ;    end if ;    $priority$ ;    @luint priority ;    $literal_integer$ ? priority ;    @luint offset ;    @bool explicitOffset ;    select      $offset$ ;      $literal_integer$ ? offset ;      explicitOffset := true ;    or      offset := [@luint new !0 !here] ;      explicitOffset := false ;    end select ;    @luint deadline ;    select      $deadline$ ;      $literal_integer$ ? deadline ;    or      deadline := [@luint new !4294967295 !here] ;    end select ;    @AC_canMessage messageKind ;    @luint period ;    select      $period$ ;      $literal_integer$ ? period ;      messageKind := [@C_canIndependantMessage new] ;    or      $on$ ;      if explicitOffset then        error here : "A dependant task cannot have an offset" ;      end if ;      select        $message$ ;        @lstring name ;        $identifier$ ? name ;        @luint messageIndex ;        [!?outMessagesMap searchKeyGetIndex !name ?messageIndex ?* ?* ?* ?* ?* ?* ?period ?*] ;        messageKind := [@C_canMessageFromMessage new !messageIndex] ;      or        $task$ ;        @lstring taskName ;        $identifier$ ? taskName ;        @luint taskIndex ;        [!?outTaskMap searchKeyGetIndex !taskName ?taskIndex ?* ?* ?* ?* ?* ?* ?period ?*] ;        messageKind := [@C_canMessageFromTask new !taskIndex] ;      end select ;    end select ;    [!?outMessagesMap insertKey !messageName         !messageClass !networkIndex !bytesCount !priority !offset !deadline !period !messageKind] ;    $;$ ;          end repeat ;  $end$ ;  action performComputations    !?outProcessorMap    !?outNetworkMap    !?outMessagesMap    !?outTaskMap  ;end rule ;end syntax ;#---------------------------------------------------------------------------*option oa_cli_options :  @bool createIntermediateFiles : 'C', "create-intermediate-files" -> "Create the intermediate files" ;  @bool forceBalgorithm : 'B', "force-B-algorithm" -> "For independant resources, force B algorithm" ;  @bool useCANmaxLegth : 'M', "use-can-max-length" -> "Use only CAN messages max length" ;end option ;#---------------------------------------------------------------------------*#                                                                           *#   G R A M M A R                                                           *#                                                                           *#---------------------------------------------------------------------------*grammar oa_grammar "LL1" :  import lexique oa_scanner ;  import option oa_cli_options ;  import syntax oa_parser ;  start <axiome> ;end grammar ;#---------------------------------------------------------------------------*#                                                                           *#   C O C O A                                                               *#                                                                           *#---------------------------------------------------------------------------*cocoa cocoaOA :program "nprt" ;import grammar oa_grammar ;end cocoa ;#---------------------------------------------------------------------------*#                                                                           *#   P R O G R A M                                                           *#                                                                           *#---------------------------------------------------------------------------*program oa_main "version 1.1.9" . "nprt" :  import grammar oa_grammar ;#--- max error and warning count  error 100 ;  warning 100 ;end program ;#--------------------------------------------------------------------------------*