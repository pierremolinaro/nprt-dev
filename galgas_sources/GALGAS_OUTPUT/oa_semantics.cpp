//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'oa_semantics.cpp'                           *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     february 6th, 2010, at 18h5'37"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "oa_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "oa_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_M_processor'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_processor::e_M_processor (void) :
mIndex (),
mStep () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@M_processor'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_processor ("M_processor", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_processor::
elementOf_GGS_M_processor (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_processor & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_processor::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStep.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_processor::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_processor * ptr = dynamic_cast <const elementOf_GGS_M_processor *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue ()
           && (mInfo.mStep.operator_isEqual (ptr->mInfo.mStep)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_processor::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_processor *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_processor * info = (e_M_processor *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_processor *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_processor * info = (e_M_processor *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_processor result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_processor info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_processor::
operator_isEqual (const GGS_M_processor & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_processor::
operator_isNotEqual (const GGS_M_processor & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_luint & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_processor info  ;
    info.mIndex = inParameter0 ;
    info.mStep = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    outParameter1 = node->mInfo.mStep ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_processor::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_processor::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_luint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_processor::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_processor::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_luint & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_processor & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_processor result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_processor result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_processor::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_processor " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_processor::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_processor::cEnumerator::_mStep (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStep ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_processor::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_processor * p = NULL ;
    macroMyNew (p, GGS_M_processor (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_processor result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_processor * p = dynamic_cast <const GGS_M_processor *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_processor, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_processor::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_processor ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_M_network'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_network::e_M_network (void) :
mIndex (),
mCANnetwork (),
mScalingFactor () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@M_network'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_network ("M_network", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_network::
elementOf_GGS_M_network (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_network & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_network::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCANnetwork.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mScalingFactor.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_network::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_network * ptr = dynamic_cast <const elementOf_GGS_M_network *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue ()
           && (mInfo.mCANnetwork.operator_isEqual (ptr->mInfo.mCANnetwork)).boolValue ()
           && (mInfo.mScalingFactor.operator_isEqual (ptr->mInfo.mScalingFactor)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_network::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_network *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_network * info = (e_M_network *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_network *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_network * info = (e_M_network *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_network result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_network info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_network::
operator_isEqual (const GGS_M_network & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_network::
operator_isNotEqual (const GGS_M_network & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_bool& inParameter1,
                const GGS_luint & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_network info  ;
    info.mIndex = inParameter0 ;
    info.mCANnetwork = inParameter1 ;
    info.mScalingFactor = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    outParameter1 = node->mInfo.mCANnetwork ;
    outParameter2 = node->mInfo.mScalingFactor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_network::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_network::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_luint   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_network::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('p'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_network::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_luint & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_network & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_network result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_network result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_network::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_network " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_network::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_M_network::cEnumerator::_mCANnetwork (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCANnetwork ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_network::cEnumerator::_mScalingFactor (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mScalingFactor ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_network::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_network * p = NULL ;
    macroMyNew (p, GGS_M_network (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_network result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_network * p = dynamic_cast <const GGS_M_network *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_network, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_network::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_network ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_AC_canMessage'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_canMessage::
cPtr_AC_canMessage (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_canMessage * GGS_AC_canMessage::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_AC_canMessage) ;
    return (cPtr_AC_canMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_canMessage::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_canMessage:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_canMessage::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_canMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_canMessage (& typeid (cPtr_AC_canMessage), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_canMessage::galgasRTTI (void) const {
  return & gClassInfoFor__AC_canMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_canMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_canMessage ("AC_canMessage", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_canMessage GGS_AC_canMessage::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_canMessage result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_canMessage *> (inPointer) != NULL)
      : (typeid (cPtr_AC_canMessage) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_canMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_canMessage),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_canMessage::actualTypeName (void) const {
  return "AC_canMessage" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_canMessage::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_canMessage ("AC_canMessage", & kTypeDescriptor_GGS_AC_canMessage) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_canMessage::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_canMessage * p = NULL ;
    macroMyNew (p, GGS_AC_canMessage (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage GGS_AC_canMessage::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_canMessage result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_canMessage * p = dynamic_cast <const GGS_AC_canMessage *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_canMessage, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_canMessage::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_canMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_C_canIndependantMessage'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canIndependantMessage::
cPtr_C_canIndependantMessage (LOCATION_ARGS)
:cPtr_AC_canMessage (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canIndependantMessage * GGS_C_canIndependantMessage::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_canIndependantMessage) ;
    return (cPtr_C_canIndependantMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_canIndependantMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canIndependantMessage::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@C_canIndependantMessage:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_canIndependantMessage::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_canIndependantMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_canIndependantMessage (& typeid (cPtr_C_canIndependantMessage), & typeid (cPtr_AC_canMessage), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_canIndependantMessage::galgasRTTI (void) const {
  return & gClassInfoFor__C_canIndependantMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canIndependantMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_canIndependantMessage ("C_canIndependantMessage", true, & kTypeDescriptor_GGS_AC_canMessage) ;

//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage::
GGS_C_canIndependantMessage (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage::
GGS_C_canIndependantMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_canIndependantMessage GGS_C_canIndependantMessage::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_canIndependantMessage result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_canIndependantMessage *> (inPointer) != NULL)
      : (typeid (cPtr_C_canIndependantMessage) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_canIndependantMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_canIndependantMessage),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_C_canIndependantMessage * gSingleton_C_canIndependantMessage = NULL ;

//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage GGS_C_canIndependantMessage::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_C_canIndependantMessage result ;
  if (NULL == gSingleton_C_canIndependantMessage) {
    macroMyNew (gSingleton_C_canIndependantMessage, cPtr_C_canIndependantMessage (THERE)) ;
    macroRetainObject (gSingleton_C_canIndependantMessage) ;
  }
  macroAssignObject (result.mPointer, gSingleton_C_canIndependantMessage) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_canIndependantMessage::actualTypeName (void) const {
  return "C_canIndependantMessage" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_canIndependantMessage ("C_canIndependantMessage", gClassInfoFor__AC_canMessage, & kTypeDescriptor_GGS_C_canIndependantMessage) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_canIndependantMessage::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_canIndependantMessage * p = NULL ;
    macroMyNew (p, GGS_C_canIndependantMessage (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage GGS_C_canIndependantMessage::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_canIndependantMessage result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_canIndependantMessage * p = dynamic_cast <const GGS_C_canIndependantMessage *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_canIndependantMessage, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_canIndependantMessage::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_canIndependantMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_C_canMessageFromMessage'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromMessage::
cPtr_C_canMessageFromMessage (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_canMessage (THERE),
mMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canMessageFromMessage * GGS_C_canMessageFromMessage::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_canMessageFromMessage) ;
    return (cPtr_C_canMessageFromMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_canMessageFromMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_canMessageFromMessage * ptr = dynamic_cast <const cPtr_C_canMessageFromMessage *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMessageIndex.operator_isEqual (ptr->mMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canMessageFromMessage::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_canMessageFromMessage:"
           << mMessageIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_canMessageFromMessage::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_canMessageFromMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_canMessageFromMessage (& typeid (cPtr_C_canMessageFromMessage), & typeid (cPtr_AC_canMessage), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_canMessageFromMessage::galgasRTTI (void) const {
  return & gClassInfoFor__C_canMessageFromMessage ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_canMessageFromMessage::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_canMessageFromMessage (mMessageIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canMessageFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_canMessageFromMessage ("C_canMessageFromMessage", true, & kTypeDescriptor_GGS_AC_canMessage) ;

//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage::
GGS_C_canMessageFromMessage (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage::
GGS_C_canMessageFromMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_canMessageFromMessage GGS_C_canMessageFromMessage::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromMessage result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_canMessageFromMessage *> (inPointer) != NULL)
      : (typeid (cPtr_C_canMessageFromMessage) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_canMessageFromMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_canMessageFromMessage),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage GGS_C_canMessageFromMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromMessage result ;
  macroMyNew (result.mPointer, cPtr_C_canMessageFromMessage (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_canMessageFromMessage::
reader_mMessageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_canMessageFromMessage *) mPointer)->mMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_canMessageFromMessage::actualTypeName (void) const {
  return "C_canMessageFromMessage" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_canMessageFromMessage ("C_canMessageFromMessage", gClassInfoFor__AC_canMessage, & kTypeDescriptor_GGS_C_canMessageFromMessage) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_canMessageFromMessage::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_canMessageFromMessage * p = NULL ;
    macroMyNew (p, GGS_C_canMessageFromMessage (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage GGS_C_canMessageFromMessage::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromMessage result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_canMessageFromMessage * p = dynamic_cast <const GGS_C_canMessageFromMessage *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_canMessageFromMessage, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_canMessageFromMessage::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_canMessageFromMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_canMessageFromTask'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromTask::
cPtr_C_canMessageFromTask (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_canMessage (THERE),
mTaskIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canMessageFromTask * GGS_C_canMessageFromTask::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_canMessageFromTask) ;
    return (cPtr_C_canMessageFromTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_canMessageFromTask::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_canMessageFromTask * ptr = dynamic_cast <const cPtr_C_canMessageFromTask *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTaskIndex.operator_isEqual (ptr->mTaskIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canMessageFromTask::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_canMessageFromTask:"
           << mTaskIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_canMessageFromTask::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_canMessageFromTask::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_canMessageFromTask (& typeid (cPtr_C_canMessageFromTask), & typeid (cPtr_AC_canMessage), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_canMessageFromTask::galgasRTTI (void) const {
  return & gClassInfoFor__C_canMessageFromTask ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_canMessageFromTask::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_canMessageFromTask (mTaskIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_canMessageFromTask'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_canMessageFromTask ("C_canMessageFromTask", true, & kTypeDescriptor_GGS_AC_canMessage) ;

//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask::
GGS_C_canMessageFromTask (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask::
GGS_C_canMessageFromTask (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_canMessageFromTask GGS_C_canMessageFromTask::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromTask result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_canMessageFromTask *> (inPointer) != NULL)
      : (typeid (cPtr_C_canMessageFromTask) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_canMessageFromTask (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_canMessageFromTask),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask GGS_C_canMessageFromTask::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromTask result ;
  macroMyNew (result.mPointer, cPtr_C_canMessageFromTask (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_canMessageFromTask::
reader_mTaskIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_canMessageFromTask *) mPointer)->mTaskIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_canMessageFromTask::actualTypeName (void) const {
  return "C_canMessageFromTask" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_canMessageFromTask ("C_canMessageFromTask", gClassInfoFor__AC_canMessage, & kTypeDescriptor_GGS_C_canMessageFromTask) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_canMessageFromTask::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_canMessageFromTask * p = NULL ;
    macroMyNew (p, GGS_C_canMessageFromTask (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask GGS_C_canMessageFromTask::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromTask result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_canMessageFromTask * p = dynamic_cast <const GGS_C_canMessageFromTask *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_canMessageFromTask, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_canMessageFromTask::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_canMessageFromTask ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_M_messages'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_messages::e_M_messages (void) :
mIndex (),
mClass (),
mNetworkIndex (),
mBytesCount (),
mPriority (),
mOffset (),
mDeadline (),
mPeriod (),
mMessageKind () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@M_messages'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_messages ("M_messages", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_messages::
elementOf_GGS_M_messages (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_messages & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_messages::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mClass.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mNetworkIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mBytesCount.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mPriority.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mOffset.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDeadline.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mPeriod.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMessageKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_messages::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_messages * ptr = dynamic_cast <const elementOf_GGS_M_messages *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue ()
           && (mInfo.mClass.operator_isEqual (ptr->mInfo.mClass)).boolValue ()
           && (mInfo.mNetworkIndex.operator_isEqual (ptr->mInfo.mNetworkIndex)).boolValue ()
           && (mInfo.mBytesCount.operator_isEqual (ptr->mInfo.mBytesCount)).boolValue ()
           && (mInfo.mPriority.operator_isEqual (ptr->mInfo.mPriority)).boolValue ()
           && (mInfo.mOffset.operator_isEqual (ptr->mInfo.mOffset)).boolValue ()
           && (mInfo.mDeadline.operator_isEqual (ptr->mInfo.mDeadline)).boolValue ()
           && (mInfo.mPeriod.operator_isEqual (ptr->mInfo.mPeriod)).boolValue ()
           && (mInfo.mMessageKind.operator_isEqual (ptr->mInfo.mMessageKind)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_messages::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_messages *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_messages * info = (e_M_messages *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_messages *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_messages * info = (e_M_messages *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_messages result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_messages info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_messages::
operator_isEqual (const GGS_M_messages & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_messages::
operator_isNotEqual (const GGS_M_messages & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_luint & inParameter1,
                const GGS_uint & inParameter2,
                const GGS_luint & inParameter3,
                const GGS_luint & inParameter4,
                const GGS_luint & inParameter5,
                const GGS_luint & inParameter6,
                const GGS_luint & inParameter7,
                const GGS_AC_canMessage & inParameter8,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inParameter7.isBuilt ()
   && inParameter8.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_messages info  ;
    info.mIndex = inParameter0 ;
    info.mClass = inParameter1 ;
    info.mNetworkIndex = inParameter2 ;
    info.mBytesCount = inParameter3 ;
    info.mPriority = inParameter4 ;
    info.mOffset = inParameter5 ;
    info.mDeadline = inParameter6 ;
    info.mPeriod = inParameter7 ;
    info.mMessageKind = inParameter8 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_uint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_luint   & outParameter7,
               GGS_AC_canMessage   & outParameter8,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    outParameter5.drop () ;
    outParameter6.drop () ;
    outParameter7.drop () ;
    outParameter8.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    outParameter1 = node->mInfo.mClass ;
    outParameter2 = node->mInfo.mNetworkIndex ;
    outParameter3 = node->mInfo.mBytesCount ;
    outParameter4 = node->mInfo.mPriority ;
    outParameter5 = node->mInfo.mOffset ;
    outParameter6 = node->mInfo.mDeadline ;
    outParameter7 = node->mInfo.mPeriod ;
    outParameter8 = node->mInfo.mMessageKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_messages::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('C'),
  TO_UNICODE ('A'),
  TO_UNICODE ('N'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_messages::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_uint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_luint   & outParameter7,
                                GGS_AC_canMessage   & outParameter8 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  outParameter8,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_messages::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('C'),
  TO_UNICODE ('A'),
  TO_UNICODE ('N'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_messages::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_uint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_luint & inParameter7,
                                const GGS_AC_canMessage & inParameter8 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 inParameter8,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_messages & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_messages result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_messages result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_messages::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_messages " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_messages::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_messages::cEnumerator::_mClass (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_messages::cEnumerator::_mNetworkIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNetworkIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_messages::cEnumerator::_mBytesCount (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mBytesCount ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_messages::cEnumerator::_mPriority (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mPriority ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_messages::cEnumerator::_mOffset (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOffset ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_messages::cEnumerator::_mDeadline (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDeadline ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_messages::cEnumerator::_mPeriod (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mPeriod ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_canMessage  & GGS_M_messages::cEnumerator::_mMessageKind (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMessageKind ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_messages::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_messages * p = NULL ;
    macroMyNew (p, GGS_M_messages (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_messages result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_messages * p = dynamic_cast <const GGS_M_messages *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_messages, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_messages::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_messages ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_AC_task'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_task::
cPtr_AC_task (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_task * GGS_AC_task::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_AC_task) ;
    return (cPtr_AC_task *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_task::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_task:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_task::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_task::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_task (& typeid (cPtr_AC_task), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_task::galgasRTTI (void) const {
  return & gClassInfoFor__AC_task ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_task'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_task ("AC_task", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_task GGS_AC_task::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_task result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_task *> (inPointer) != NULL)
      : (typeid (cPtr_AC_task) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_task (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_task),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_task::actualTypeName (void) const {
  return "AC_task" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_task::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_task ("AC_task", & kTypeDescriptor_GGS_AC_task) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_task::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_task * p = NULL ;
    macroMyNew (p, GGS_AC_task (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_task GGS_AC_task::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_task result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_task * p = dynamic_cast <const GGS_AC_task *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_task, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_task::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_task ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_independantTask'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_independantTask::
cPtr_C_independantTask (LOCATION_ARGS)
:cPtr_AC_task (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_independantTask * GGS_C_independantTask::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_independantTask) ;
    return (cPtr_C_independantTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_independantTask::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_independantTask::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@C_independantTask:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_independantTask::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_independantTask::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_independantTask (& typeid (cPtr_C_independantTask), & typeid (cPtr_AC_task), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_independantTask::galgasRTTI (void) const {
  return & gClassInfoFor__C_independantTask ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_independantTask'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_independantTask ("C_independantTask", true, & kTypeDescriptor_GGS_AC_task) ;

//---------------------------------------------------------------------------*

GGS_C_independantTask::
GGS_C_independantTask (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_independantTask::
GGS_C_independantTask (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_independantTask GGS_C_independantTask::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_independantTask result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_independantTask *> (inPointer) != NULL)
      : (typeid (cPtr_C_independantTask) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_independantTask (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_independantTask),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_C_independantTask * gSingleton_C_independantTask = NULL ;

//---------------------------------------------------------------------------*

GGS_C_independantTask GGS_C_independantTask::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_C_independantTask result ;
  if (NULL == gSingleton_C_independantTask) {
    macroMyNew (gSingleton_C_independantTask, cPtr_C_independantTask (THERE)) ;
    macroRetainObject (gSingleton_C_independantTask) ;
  }
  macroAssignObject (result.mPointer, gSingleton_C_independantTask) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_independantTask::actualTypeName (void) const {
  return "C_independantTask" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_independantTask ("C_independantTask", gClassInfoFor__AC_task, & kTypeDescriptor_GGS_C_independantTask) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_independantTask::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_independantTask * p = NULL ;
    macroMyNew (p, GGS_C_independantTask (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_independantTask GGS_C_independantTask::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_independantTask result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_independantTask * p = dynamic_cast <const GGS_C_independantTask *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_independantTask, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_independantTask::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_independantTask ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_taskDependsFromTask'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromTask::
cPtr_C_taskDependsFromTask (const GGS_uint & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_task (THERE),
mTask (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_taskDependsFromTask * GGS_C_taskDependsFromTask::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_taskDependsFromTask) ;
    return (cPtr_C_taskDependsFromTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_taskDependsFromTask::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_taskDependsFromTask * ptr = dynamic_cast <const cPtr_C_taskDependsFromTask *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTask.operator_isEqual (ptr->mTask).boolValue ()
         && mEvery.operator_isEqual (ptr->mEvery).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_taskDependsFromTask::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_taskDependsFromTask:"
           << mTask.reader_description (inIndentation + 1)
           << mEvery.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_taskDependsFromTask::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_taskDependsFromTask::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_taskDependsFromTask (& typeid (cPtr_C_taskDependsFromTask), & typeid (cPtr_AC_task), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_taskDependsFromTask::galgasRTTI (void) const {
  return & gClassInfoFor__C_taskDependsFromTask ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_taskDependsFromTask::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_taskDependsFromTask (mTask, mEvery COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_taskDependsFromTask'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_taskDependsFromTask ("C_taskDependsFromTask", true, & kTypeDescriptor_GGS_AC_task) ;

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask::
GGS_C_taskDependsFromTask (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask::
GGS_C_taskDependsFromTask (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_taskDependsFromTask GGS_C_taskDependsFromTask::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromTask result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_taskDependsFromTask *> (inPointer) != NULL)
      : (typeid (cPtr_C_taskDependsFromTask) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_taskDependsFromTask (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_taskDependsFromTask),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask GGS_C_taskDependsFromTask::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromTask result ;
  macroMyNew (result.mPointer, cPtr_C_taskDependsFromTask (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_taskDependsFromTask::
reader_mTask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromTask *) mPointer)->mTask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromTask::
reader_mEvery (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromTask *) mPointer)->mEvery ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_taskDependsFromTask::actualTypeName (void) const {
  return "C_taskDependsFromTask" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_taskDependsFromTask ("C_taskDependsFromTask", gClassInfoFor__AC_task, & kTypeDescriptor_GGS_C_taskDependsFromTask) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_taskDependsFromTask::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_taskDependsFromTask * p = NULL ;
    macroMyNew (p, GGS_C_taskDependsFromTask (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask GGS_C_taskDependsFromTask::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromTask result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_taskDependsFromTask * p = dynamic_cast <const GGS_C_taskDependsFromTask *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_taskDependsFromTask, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_taskDependsFromTask::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_taskDependsFromTask ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_C_taskDependsFromMessage'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromMessage::
cPtr_C_taskDependsFromMessage (const GGS_uint & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_task (THERE),
mMessage (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_taskDependsFromMessage * GGS_C_taskDependsFromMessage::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_taskDependsFromMessage) ;
    return (cPtr_C_taskDependsFromMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_taskDependsFromMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_taskDependsFromMessage * ptr = dynamic_cast <const cPtr_C_taskDependsFromMessage *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMessage.operator_isEqual (ptr->mMessage).boolValue ()
         && mEvery.operator_isEqual (ptr->mEvery).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_taskDependsFromMessage::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_taskDependsFromMessage:"
           << mMessage.reader_description (inIndentation + 1)
           << mEvery.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_taskDependsFromMessage::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_taskDependsFromMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_taskDependsFromMessage (& typeid (cPtr_C_taskDependsFromMessage), & typeid (cPtr_AC_task), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_taskDependsFromMessage::galgasRTTI (void) const {
  return & gClassInfoFor__C_taskDependsFromMessage ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_taskDependsFromMessage::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_taskDependsFromMessage (mMessage, mEvery COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_taskDependsFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_taskDependsFromMessage ("C_taskDependsFromMessage", true, & kTypeDescriptor_GGS_AC_task) ;

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage::
GGS_C_taskDependsFromMessage (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage::
GGS_C_taskDependsFromMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_taskDependsFromMessage GGS_C_taskDependsFromMessage::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromMessage result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_taskDependsFromMessage *> (inPointer) != NULL)
      : (typeid (cPtr_C_taskDependsFromMessage) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_taskDependsFromMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_taskDependsFromMessage),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage GGS_C_taskDependsFromMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromMessage result ;
  macroMyNew (result.mPointer, cPtr_C_taskDependsFromMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_taskDependsFromMessage::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromMessage *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromMessage::
reader_mEvery (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromMessage *) mPointer)->mEvery ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_taskDependsFromMessage::actualTypeName (void) const {
  return "C_taskDependsFromMessage" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_taskDependsFromMessage ("C_taskDependsFromMessage", gClassInfoFor__AC_task, & kTypeDescriptor_GGS_C_taskDependsFromMessage) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_taskDependsFromMessage::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_taskDependsFromMessage * p = NULL ;
    macroMyNew (p, GGS_C_taskDependsFromMessage (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage GGS_C_taskDependsFromMessage::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromMessage result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_taskDependsFromMessage * p = dynamic_cast <const GGS_C_taskDependsFromMessage *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_taskDependsFromMessage, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_taskDependsFromMessage::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_taskDependsFromMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'e_M_tasks'                              *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_tasks::e_M_tasks (void) :
mIndex (),
mPriority (),
mOffset (),
mDeadline (),
mDurationMin (),
mDurationMax (),
mProcessor (),
mPeriod (),
mTaskKind () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@M_tasks'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_tasks ("M_tasks", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_tasks::
elementOf_GGS_M_tasks (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_tasks & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_tasks::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mPriority.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mOffset.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDeadline.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDurationMin.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDurationMax.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mProcessor.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mPeriod.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTaskKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_tasks::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_tasks * ptr = dynamic_cast <const elementOf_GGS_M_tasks *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue ()
           && (mInfo.mPriority.operator_isEqual (ptr->mInfo.mPriority)).boolValue ()
           && (mInfo.mOffset.operator_isEqual (ptr->mInfo.mOffset)).boolValue ()
           && (mInfo.mDeadline.operator_isEqual (ptr->mInfo.mDeadline)).boolValue ()
           && (mInfo.mDurationMin.operator_isEqual (ptr->mInfo.mDurationMin)).boolValue ()
           && (mInfo.mDurationMax.operator_isEqual (ptr->mInfo.mDurationMax)).boolValue ()
           && (mInfo.mProcessor.operator_isEqual (ptr->mInfo.mProcessor)).boolValue ()
           && (mInfo.mPeriod.operator_isEqual (ptr->mInfo.mPeriod)).boolValue ()
           && (mInfo.mTaskKind.operator_isEqual (ptr->mInfo.mTaskKind)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_tasks::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_tasks *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_tasks * info = (e_M_tasks *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_tasks *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_tasks * info = (e_M_tasks *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_tasks result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_tasks info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_tasks::
operator_isEqual (const GGS_M_tasks & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_tasks::
operator_isNotEqual (const GGS_M_tasks & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_luint & inParameter1,
                const GGS_luint & inParameter2,
                const GGS_luint & inParameter3,
                const GGS_luint & inParameter4,
                const GGS_luint & inParameter5,
                const GGS_uint & inParameter6,
                const GGS_luint & inParameter7,
                const GGS_AC_task & inParameter8,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inParameter7.isBuilt ()
   && inParameter8.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_tasks info  ;
    info.mIndex = inParameter0 ;
    info.mPriority = inParameter1 ;
    info.mOffset = inParameter2 ;
    info.mDeadline = inParameter3 ;
    info.mDurationMin = inParameter4 ;
    info.mDurationMax = inParameter5 ;
    info.mProcessor = inParameter6 ;
    info.mPeriod = inParameter7 ;
    info.mTaskKind = inParameter8 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_uint   & outParameter6,
               GGS_luint   & outParameter7,
               GGS_AC_task   & outParameter8,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    outParameter5.drop () ;
    outParameter6.drop () ;
    outParameter7.drop () ;
    outParameter8.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    outParameter1 = node->mInfo.mPriority ;
    outParameter2 = node->mInfo.mOffset ;
    outParameter3 = node->mInfo.mDeadline ;
    outParameter4 = node->mInfo.mDurationMin ;
    outParameter5 = node->mInfo.mDurationMax ;
    outParameter6 = node->mInfo.mProcessor ;
    outParameter7 = node->mInfo.mPeriod ;
    outParameter8 = node->mInfo.mTaskKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_tasks::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_tasks::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_uint   & outParameter6,
                                GGS_luint   & outParameter7,
                                GGS_AC_task   & outParameter8 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  outParameter8,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_tasks::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('k'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_tasks::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_uint & inParameter6,
                                const GGS_luint & inParameter7,
                                const GGS_AC_task & inParameter8 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 inParameter8,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_tasks & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_tasks result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_tasks result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_tasks::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_tasks " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_tasks::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_tasks::cEnumerator::_mPriority (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mPriority ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_tasks::cEnumerator::_mOffset (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mOffset ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_tasks::cEnumerator::_mDeadline (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDeadline ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_tasks::cEnumerator::_mDurationMin (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDurationMin ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_tasks::cEnumerator::_mDurationMax (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDurationMax ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_tasks::cEnumerator::_mProcessor (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mProcessor ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_M_tasks::cEnumerator::_mPeriod (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mPeriod ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_task  & GGS_M_tasks::cEnumerator::_mTaskKind (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTaskKind ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_tasks::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_tasks * p = NULL ;
    macroMyNew (p, GGS_M_tasks (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_tasks result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_tasks * p = dynamic_cast <const GGS_M_tasks *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_tasks, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_tasks::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_tasks ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_oa_semantics (void) {
  macroReleaseObject (gSingleton_C_canIndependantMessage) ;
  macroReleaseObject (gSingleton_C_independantTask) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_oa_semantics (NULL, epilogueRoutineFor_oa_semantics) ;

//---------------------------------------------------------------------------*

