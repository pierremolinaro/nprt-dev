//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'oa_semantics.cpp'                           *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      june 17th, 2008, at 20h46'26"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "oa_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "oa_semantics.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_M_processor'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_processor::e_M_processor (void) :
mStep () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@M_processor'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_processor::
elementOf_GGS_M_processor (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_processor & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_processor::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mStep.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_processor::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_processor * _p = dynamic_cast <const elementOf_GGS_M_processor *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mStep._operator_isEqual (_p->mInfo.mStep)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_processor::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_processor *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_processor * info = (e_M_processor *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_processor *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_processor * info = (e_M_processor *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_processor result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_processor info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_processor::
_operator_isEqual (const GGS_M_processor & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_processor::
_operator_isNotEqual (const GGS_M_processor & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_luint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_processor info  ;
    info.mStep = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStep ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the processor '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
method_searchKeyGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the processor '%K' is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the processor '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_processor & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_processor result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_processor result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_processor::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_processor " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_M_network'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_network::e_M_network (void) :
mCANnetwork (),
mScalingFactor () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@M_network'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_network::
elementOf_GGS_M_network (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_network & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_network::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mCANnetwork.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mScalingFactor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_network::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_network * _p = dynamic_cast <const elementOf_GGS_M_network *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mCANnetwork._operator_isEqual (_p->mInfo.mCANnetwork)).boolValue ()
           && (mInfo.mScalingFactor._operator_isEqual (_p->mInfo.mScalingFactor)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_network::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_network *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_network * info = (e_M_network *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_network *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_network * info = (e_M_network *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_network result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_network info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_network::
_operator_isEqual (const GGS_M_network & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_network::
_operator_isNotEqual (const GGS_M_network & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_bool& inParameter0,
                const GGS_luint & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_network info  ;
    info.mCANnetwork = inParameter0 ;
    info.mScalingFactor = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mCANnetwork ;
    outParameter1 = node->mInfo.mScalingFactor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_luint   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the processor '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
method_searchKeyGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_bool  & outParameter0,
                                GGS_luint   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the processor '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_luint & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the processor '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_network & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_network result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_network result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_network::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_network " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_AC_canMessage'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_canMessage::
cPtr_AC_canMessage (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_canMessage * GGS_AC_canMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_canMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_canMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_canMessage::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_canMessage:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_canMessage::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_canMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_canMessage (& typeid (cPtr_AC_canMessage), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_AC_canMessage::galgasRTTI (void) const {
  return & gClassInfoFor__AC_canMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_canMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_AC_canMessage GGS_AC_canMessage::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_canMessage _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_canMessage *> (inPointer) != NULL)
      : (typeid (cPtr_AC_canMessage) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_AC_canMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_canMessage),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_canMessage::actualTypeName (void) const {
  return "AC_canMessage" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_AC_canMessage::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__AC_canMessage ("AC_canMessage") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_C_canIndependantMessage'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canIndependantMessage::
cPtr_C_canIndependantMessage (LOCATION_ARGS)
:cPtr_AC_canMessage (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canIndependantMessage * GGS_C_canIndependantMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canIndependantMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_canIndependantMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_canIndependantMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canIndependantMessage::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_canIndependantMessage:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_canIndependantMessage::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_canIndependantMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_canIndependantMessage (& typeid (cPtr_C_canIndependantMessage), & typeid (cPtr_AC_canMessage), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_canIndependantMessage::galgasRTTI (void) const {
  return & gClassInfoFor__C_canIndependantMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canIndependantMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage::
GGS_C_canIndependantMessage (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage::
GGS_C_canIndependantMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_canIndependantMessage GGS_C_canIndependantMessage::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_canIndependantMessage _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_canIndependantMessage *> (inPointer) != NULL)
      : (typeid (cPtr_C_canIndependantMessage) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_canIndependantMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_canIndependantMessage),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_C_canIndependantMessage * gSingleton_C_canIndependantMessage = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_C_canIndependantMessage (void) {
  macroDetachPointer (gSingleton_C_canIndependantMessage, cPtr_C_canIndependantMessage) ;
}

//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage GGS_C_canIndependantMessage::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_C_canIndependantMessage result ;
  if (NULL == gSingleton_C_canIndependantMessage) {
    macroMyNew (gSingleton_C_canIndependantMessage, cPtr_C_canIndependantMessage (THERE)) ;
    registerReleaseRoutine (cleanUp_C_canIndependantMessage) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_C_canIndependantMessage) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_canIndependantMessage::actualTypeName (void) const {
  return "C_canIndependantMessage" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_canIndependantMessage ("C_canIndependantMessage", gClassInfoFor__AC_canMessage) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_C_canMessageFromMessage'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromMessage::
cPtr_C_canMessageFromMessage (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_canMessage (THERE),
mMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canMessageFromMessage * GGS_C_canMessageFromMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_canMessageFromMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_canMessageFromMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_canMessageFromMessage * _p = dynamic_cast <const cPtr_C_canMessageFromMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageIndex._operator_isEqual (_p->mMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canMessageFromMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_canMessageFromMessage:"
           << mMessageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_canMessageFromMessage::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_canMessageFromMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_canMessageFromMessage (& typeid (cPtr_C_canMessageFromMessage), & typeid (cPtr_AC_canMessage), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_canMessageFromMessage::galgasRTTI (void) const {
  return & gClassInfoFor__C_canMessageFromMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canMessageFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage::
GGS_C_canMessageFromMessage (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage::
GGS_C_canMessageFromMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_canMessageFromMessage GGS_C_canMessageFromMessage::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromMessage _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_canMessageFromMessage *> (inPointer) != NULL)
      : (typeid (cPtr_C_canMessageFromMessage) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_canMessageFromMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_canMessageFromMessage),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage GGS_C_canMessageFromMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromMessage result ;
  macroMyNew (result.mPointer, cPtr_C_canMessageFromMessage (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_canMessageFromMessage::
reader_mMessageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_canMessageFromMessage *) mPointer)->mMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_canMessageFromMessage::actualTypeName (void) const {
  return "C_canMessageFromMessage" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_canMessageFromMessage ("C_canMessageFromMessage", gClassInfoFor__AC_canMessage) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_canMessageFromTask'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromTask::
cPtr_C_canMessageFromTask (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_canMessage (THERE),
mTaskIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canMessageFromTask * GGS_C_canMessageFromTask::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_canMessageFromTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_canMessageFromTask::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_canMessageFromTask * _p = dynamic_cast <const cPtr_C_canMessageFromTask *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTaskIndex._operator_isEqual (_p->mTaskIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canMessageFromTask::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_canMessageFromTask:"
           << mTaskIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_canMessageFromTask::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_canMessageFromTask::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_canMessageFromTask (& typeid (cPtr_C_canMessageFromTask), & typeid (cPtr_AC_canMessage), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_canMessageFromTask::galgasRTTI (void) const {
  return & gClassInfoFor__C_canMessageFromTask ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_canMessageFromTask'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask::
GGS_C_canMessageFromTask (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask::
GGS_C_canMessageFromTask (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_canMessageFromTask GGS_C_canMessageFromTask::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromTask _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_canMessageFromTask *> (inPointer) != NULL)
      : (typeid (cPtr_C_canMessageFromTask) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_canMessageFromTask (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_canMessageFromTask),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask GGS_C_canMessageFromTask::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_canMessageFromTask result ;
  macroMyNew (result.mPointer, cPtr_C_canMessageFromTask (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_canMessageFromTask::
reader_mTaskIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_canMessageFromTask *) mPointer)->mTaskIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_canMessageFromTask::actualTypeName (void) const {
  return "C_canMessageFromTask" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_canMessageFromTask ("C_canMessageFromTask", gClassInfoFor__AC_canMessage) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_M_messages'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_messages::e_M_messages (void) :
mClass (),
mNetworkIndex (),
mBytesCount (),
mPriority (),
mOffset (),
mDeadline (),
mPeriod (),
mMessageKind () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@M_messages'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_messages::
elementOf_GGS_M_messages (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_messages & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_messages::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mClass.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mNetworkIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mBytesCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mPriority.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDeadline.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mPeriod.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessageKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_messages::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_messages * _p = dynamic_cast <const elementOf_GGS_M_messages *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mClass._operator_isEqual (_p->mInfo.mClass)).boolValue ()
           && (mInfo.mNetworkIndex._operator_isEqual (_p->mInfo.mNetworkIndex)).boolValue ()
           && (mInfo.mBytesCount._operator_isEqual (_p->mInfo.mBytesCount)).boolValue ()
           && (mInfo.mPriority._operator_isEqual (_p->mInfo.mPriority)).boolValue ()
           && (mInfo.mOffset._operator_isEqual (_p->mInfo.mOffset)).boolValue ()
           && (mInfo.mDeadline._operator_isEqual (_p->mInfo.mDeadline)).boolValue ()
           && (mInfo.mPeriod._operator_isEqual (_p->mInfo.mPeriod)).boolValue ()
           && (mInfo.mMessageKind._operator_isEqual (_p->mInfo.mMessageKind)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_messages::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_messages *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_messages * info = (e_M_messages *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_messages *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_messages * info = (e_M_messages *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_messages result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_messages info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_messages::
_operator_isEqual (const GGS_M_messages & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_messages::
_operator_isNotEqual (const GGS_M_messages & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_luint & inParameter0,
                const GGS_luint & inParameter1,
                const GGS_luint & inParameter2,
                const GGS_luint & inParameter3,
                const GGS_luint & inParameter4,
                const GGS_luint & inParameter5,
                const GGS_luint & inParameter6,
                const GGS_AC_canMessage & inParameter7,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inParameter6._isBuilt ()
   && inParameter7._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_messages info  ;
    info.mClass = inParameter0 ;
    info.mNetworkIndex = inParameter1 ;
    info.mBytesCount = inParameter2 ;
    info.mPriority = inParameter3 ;
    info.mOffset = inParameter4 ;
    info.mDeadline = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mMessageKind = inParameter7 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_AC_canMessage   & outParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    outParameter4._drop_operation () ;
    outParameter5._drop_operation () ;
    outParameter6._drop_operation () ;
    outParameter7._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mClass ;
    outParameter1 = node->mInfo.mNetworkIndex ;
    outParameter2 = node->mInfo.mBytesCount ;
    outParameter3 = node->mInfo.mPriority ;
    outParameter4 = node->mInfo.mOffset ;
    outParameter5 = node->mInfo.mDeadline ;
    outParameter6 = node->mInfo.mPeriod ;
    outParameter7 = node->mInfo.mMessageKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_canMessage   & outParameter7 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the CAN message '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
method_searchKeyGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_canMessage   & outParameter7 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the CAN message '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_canMessage & inParameter7 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the CAN message '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_messages & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_messages result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_messages result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_messages::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_messages " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_AC_task'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_task::
cPtr_AC_task (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_task * GGS_AC_task::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_task *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_task *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_task::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_task:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_task::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_task::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_task (& typeid (cPtr_AC_task), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_AC_task::galgasRTTI (void) const {
  return & gClassInfoFor__AC_task ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_task'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_AC_task GGS_AC_task::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_task _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_task *> (inPointer) != NULL)
      : (typeid (cPtr_AC_task) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_AC_task (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_task),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_task::actualTypeName (void) const {
  return "AC_task" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_AC_task::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__AC_task ("AC_task") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_independantTask'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_independantTask::
cPtr_C_independantTask (LOCATION_ARGS)
:cPtr_AC_task (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_independantTask * GGS_C_independantTask::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_independantTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_independantTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_independantTask::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_independantTask::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_independantTask:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_independantTask::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_independantTask::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_independantTask (& typeid (cPtr_C_independantTask), & typeid (cPtr_AC_task), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_independantTask::galgasRTTI (void) const {
  return & gClassInfoFor__C_independantTask ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_independantTask'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_independantTask::
GGS_C_independantTask (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_independantTask::
GGS_C_independantTask (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_independantTask GGS_C_independantTask::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_independantTask _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_independantTask *> (inPointer) != NULL)
      : (typeid (cPtr_C_independantTask) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_independantTask (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_independantTask),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_C_independantTask * gSingleton_C_independantTask = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_C_independantTask (void) {
  macroDetachPointer (gSingleton_C_independantTask, cPtr_C_independantTask) ;
}

//---------------------------------------------------------------------------*

GGS_C_independantTask GGS_C_independantTask::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_C_independantTask result ;
  if (NULL == gSingleton_C_independantTask) {
    macroMyNew (gSingleton_C_independantTask, cPtr_C_independantTask (THERE)) ;
    registerReleaseRoutine (cleanUp_C_independantTask) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_C_independantTask) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_independantTask::actualTypeName (void) const {
  return "C_independantTask" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_independantTask ("C_independantTask", gClassInfoFor__AC_task) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_taskDependsFromTask'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromTask::
cPtr_C_taskDependsFromTask (const GGS_luint & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_task (THERE),
mTask (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_taskDependsFromTask * GGS_C_taskDependsFromTask::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_taskDependsFromTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_taskDependsFromTask::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_taskDependsFromTask * _p = dynamic_cast <const cPtr_C_taskDependsFromTask *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTask._operator_isEqual (_p->mTask).boolValue ()
         && mEvery._operator_isEqual (_p->mEvery).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_taskDependsFromTask::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_taskDependsFromTask:"
           << mTask.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEvery.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_taskDependsFromTask::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_taskDependsFromTask::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_taskDependsFromTask (& typeid (cPtr_C_taskDependsFromTask), & typeid (cPtr_AC_task), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_taskDependsFromTask::galgasRTTI (void) const {
  return & gClassInfoFor__C_taskDependsFromTask ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_taskDependsFromTask'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask::
GGS_C_taskDependsFromTask (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask::
GGS_C_taskDependsFromTask (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_taskDependsFromTask GGS_C_taskDependsFromTask::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromTask _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_taskDependsFromTask *> (inPointer) != NULL)
      : (typeid (cPtr_C_taskDependsFromTask) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_taskDependsFromTask (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_taskDependsFromTask),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask GGS_C_taskDependsFromTask::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromTask result ;
  macroMyNew (result.mPointer, cPtr_C_taskDependsFromTask (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromTask::
reader_mTask (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromTask *) mPointer)->mTask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromTask::
reader_mEvery (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromTask *) mPointer)->mEvery ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_taskDependsFromTask::actualTypeName (void) const {
  return "C_taskDependsFromTask" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_taskDependsFromTask ("C_taskDependsFromTask", gClassInfoFor__AC_task) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_C_taskDependsFromMessage'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromMessage::
cPtr_C_taskDependsFromMessage (const GGS_luint & argument_0,
                                const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_task (THERE),
mMessage (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_taskDependsFromMessage * GGS_C_taskDependsFromMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_taskDependsFromMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_taskDependsFromMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_taskDependsFromMessage * _p = dynamic_cast <const cPtr_C_taskDependsFromMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessage._operator_isEqual (_p->mMessage).boolValue ()
         && mEvery._operator_isEqual (_p->mEvery).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_taskDependsFromMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_taskDependsFromMessage:"
           << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEvery.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_taskDependsFromMessage::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_taskDependsFromMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_taskDependsFromMessage (& typeid (cPtr_C_taskDependsFromMessage), & typeid (cPtr_AC_task), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_taskDependsFromMessage::galgasRTTI (void) const {
  return & gClassInfoFor__C_taskDependsFromMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_taskDependsFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage::
GGS_C_taskDependsFromMessage (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage::
GGS_C_taskDependsFromMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_taskDependsFromMessage GGS_C_taskDependsFromMessage::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromMessage _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_taskDependsFromMessage *> (inPointer) != NULL)
      : (typeid (cPtr_C_taskDependsFromMessage) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_taskDependsFromMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_taskDependsFromMessage),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage GGS_C_taskDependsFromMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_taskDependsFromMessage result ;
  macroMyNew (result.mPointer, cPtr_C_taskDependsFromMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromMessage::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromMessage *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromMessage::
reader_mEvery (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromMessage *) mPointer)->mEvery ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_taskDependsFromMessage::actualTypeName (void) const {
  return "C_taskDependsFromMessage" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_taskDependsFromMessage ("C_taskDependsFromMessage", gClassInfoFor__AC_task) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'e_M_tasks'                              *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_tasks::e_M_tasks (void) :
mPriority (),
mOffset (),
mDeadline (),
mDurationMin (),
mDurationMax (),
mProcessor (),
mPeriod (),
mTaskKind () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@M_tasks'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_tasks::
elementOf_GGS_M_tasks (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_tasks & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_tasks::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mPriority.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDeadline.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDurationMin.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDurationMax.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mProcessor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mPeriod.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTaskKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_tasks::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_tasks * _p = dynamic_cast <const elementOf_GGS_M_tasks *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mPriority._operator_isEqual (_p->mInfo.mPriority)).boolValue ()
           && (mInfo.mOffset._operator_isEqual (_p->mInfo.mOffset)).boolValue ()
           && (mInfo.mDeadline._operator_isEqual (_p->mInfo.mDeadline)).boolValue ()
           && (mInfo.mDurationMin._operator_isEqual (_p->mInfo.mDurationMin)).boolValue ()
           && (mInfo.mDurationMax._operator_isEqual (_p->mInfo.mDurationMax)).boolValue ()
           && (mInfo.mProcessor._operator_isEqual (_p->mInfo.mProcessor)).boolValue ()
           && (mInfo.mPeriod._operator_isEqual (_p->mInfo.mPeriod)).boolValue ()
           && (mInfo.mTaskKind._operator_isEqual (_p->mInfo.mTaskKind)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_tasks::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_tasks *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_tasks * info = (e_M_tasks *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_tasks *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_tasks * info = (e_M_tasks *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_tasks result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_tasks info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_tasks::
_operator_isEqual (const GGS_M_tasks & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_tasks::
_operator_isNotEqual (const GGS_M_tasks & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_luint & inParameter0,
                const GGS_luint & inParameter1,
                const GGS_luint & inParameter2,
                const GGS_luint & inParameter3,
                const GGS_luint & inParameter4,
                const GGS_luint & inParameter5,
                const GGS_luint & inParameter6,
                const GGS_AC_task & inParameter7,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inParameter6._isBuilt ()
   && inParameter7._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_tasks info  ;
    info.mPriority = inParameter0 ;
    info.mOffset = inParameter1 ;
    info.mDeadline = inParameter2 ;
    info.mDurationMin = inParameter3 ;
    info.mDurationMax = inParameter4 ;
    info.mProcessor = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mTaskKind = inParameter7 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_AC_task   & outParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    outParameter4._drop_operation () ;
    outParameter5._drop_operation () ;
    outParameter6._drop_operation () ;
    outParameter7._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mPriority ;
    outParameter1 = node->mInfo.mOffset ;
    outParameter2 = node->mInfo.mDeadline ;
    outParameter3 = node->mInfo.mDurationMin ;
    outParameter4 = node->mInfo.mDurationMax ;
    outParameter5 = node->mInfo.mProcessor ;
    outParameter6 = node->mInfo.mPeriod ;
    outParameter7 = node->mInfo.mTaskKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_task   & outParameter7 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the task '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
method_searchKeyGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_task   & outParameter7 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the task '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  outParameter7,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_task & inParameter7 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the task '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_tasks & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_tasks result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_tasks result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_tasks::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_tasks " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

