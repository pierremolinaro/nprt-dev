//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'oa_semantics.cpp'                           *
//                Generated by version 1.2.1 (LL(1) grammar)                 *
//                     november 12th, 2005, at 19h8'22"                      *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "oa_semantics.h"


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'M_processor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_processor::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_processor & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_processor::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_processor *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_processor * info = (e_M_processor *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::constructor_empty (void) {
  GGS_M_processor result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_processor info  ;
    info.mStep = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStep ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  searchElement (inLexique,
                 kErrorMessage,
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  searchElement (inLexique,
                 kErrorMessage,
                 inKey,
                 outParameter0,
                 & outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  insertElement (lexique_var_,
                 kErrorMessage,
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_network'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_network::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_network & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_network::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_network *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_network * info = (e_M_network *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::constructor_empty (void) {
  GGS_M_network result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_bool&  inParameter0,
               const GGS_luint &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_network info  ;
    info.mCANnetwork = inParameter0 ;
    info.mScalingFactor = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mCANnetwork ;
    outParameter1 = node->mInfo.mScalingFactor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_luint   & outParameter1) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  searchElement (inLexique,
                 kErrorMessage,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_bool  & outParameter0,
                                GGS_luint   & outParameter1) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  searchElement (inLexique,
                 kErrorMessage,
                 inKey,
                 outParameter0,
                 outParameter1,
                 & outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_luint & inParameter1) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  insertElement (lexique_var_,
                 kErrorMessage,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_canMessage'                     *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_canMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (void) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (const GGS_AC_canMessage & inOperand) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
~GGS_AC_canMessage (void) {
  macroDetachPointer (mPointer, cPtr_AC_canMessage) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage::
operator = (const GGS_AC_canMessage & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage::
operator = (cPtr_AC_canMessage * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (cPtr_AC_canMessage * inSource) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_canMessage * GGS_AC_canMessage
::operator () (LOCATION_ARGS) const {
  macroValidPointerThere (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_canMessage) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_canIndependantMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canIndependantMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_canIndependantMessage * GGS_C_canIndependantMessage::
    constructor_new () {
    cPtr_C_canIndependantMessage * ptr_ = (cPtr_C_canIndependantMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_canIndependantMessage ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_canMessageFromMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromMessage::cPtr_C_canMessageFromMessage (const GGS_luint & argument_0)
:mMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canMessageFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_canMessageFromMessage * GGS_C_canMessageFromMessage::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_C_canMessageFromMessage * ptr_ = (cPtr_C_canMessageFromMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_canMessageFromMessage (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_canMessageFromTask'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromTask::cPtr_C_canMessageFromTask (const GGS_luint & argument_0)
:mTaskIndex (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_canMessageFromTask'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_canMessageFromTask * GGS_C_canMessageFromTask::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_C_canMessageFromTask * ptr_ = (cPtr_C_canMessageFromTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_canMessageFromTask (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_messages'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_messages::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_messages & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_messages::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_messages *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_messages * info = (e_M_messages *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::constructor_empty (void) {
  GGS_M_messages result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               const GGS_luint &  inParameter1,
               const GGS_luint &  inParameter2,
               const GGS_luint &  inParameter3,
               const GGS_luint &  inParameter4,
               const GGS_luint &  inParameter5,
               const GGS_luint &  inParameter6,
               const GGS_AC_canMessage &  inParameter7,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_messages info  ;
    info.mClass = inParameter0 ;
    info.mNetworkIndex = inParameter1 ;
    info.mBytesCount = inParameter2 ;
    info.mPriority = inParameter3 ;
    info.mOffset = inParameter4 ;
    info.mDeadline = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mMessageKind = inParameter7 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_AC_canMessage   & outParameter7,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    outParameter7.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mClass ;
    outParameter1 = node->mInfo.mNetworkIndex ;
    outParameter2 = node->mInfo.mBytesCount ;
    outParameter3 = node->mInfo.mPriority ;
    outParameter4 = node->mInfo.mOffset ;
    outParameter5 = node->mInfo.mDeadline ;
    outParameter6 = node->mInfo.mPeriod ;
    outParameter7 = node->mInfo.mMessageKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_canMessage   & outParameter7) {
  const char * kErrorMessage [] = {"the CAN message '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  searchElement (inLexique,
                 kErrorMessage,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_canMessage   & outParameter7) {
  const char * kErrorMessage [] = {"the CAN message '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  searchElement (inLexique,
                 kErrorMessage,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 & outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_canMessage & inParameter7) {
  const char * kErrorMessage [] = {"the CAN message '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  insertElement (lexique_var_,
                 kErrorMessage,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      abstract class 'cPtr_AC_task'                        *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_task'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (void) {
  mPointer = (cPtr_AC_task *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (const GGS_AC_task & inOperand) {
  mPointer = (cPtr_AC_task *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
~GGS_AC_task (void) {
  macroDetachPointer (mPointer, cPtr_AC_task) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task::
operator = (const GGS_AC_task & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task::
operator = (cPtr_AC_task * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (cPtr_AC_task * inSource) {
  mPointer = (cPtr_AC_task *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_task * GGS_AC_task
::operator () (LOCATION_ARGS) const {
  macroValidPointerThere (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_task) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_independantTask'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_independantTask'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_independantTask * GGS_C_independantTask::
    constructor_new () {
    cPtr_C_independantTask * ptr_ = (cPtr_C_independantTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_independantTask ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_taskDependsFromTask'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromTask::cPtr_C_taskDependsFromTask (const GGS_luint & argument_0,
                                const GGS_luint & argument_1)
:mTask (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_taskDependsFromTask'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_taskDependsFromTask * GGS_C_taskDependsFromTask::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
    cPtr_C_taskDependsFromTask * ptr_ = (cPtr_C_taskDependsFromTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_taskDependsFromTask (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_taskDependsFromMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromMessage::cPtr_C_taskDependsFromMessage (const GGS_luint & argument_0,
                                const GGS_luint & argument_1)
:mMessage (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_taskDependsFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_taskDependsFromMessage * GGS_C_taskDependsFromMessage::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
    cPtr_C_taskDependsFromMessage * ptr_ = (cPtr_C_taskDependsFromMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_taskDependsFromMessage (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'M_tasks'                             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_tasks::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_tasks & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_tasks::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_tasks *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_tasks * info = (e_M_tasks *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::constructor_empty (void) {
  GGS_M_tasks result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               const GGS_luint &  inParameter1,
               const GGS_luint &  inParameter2,
               const GGS_luint &  inParameter3,
               const GGS_luint &  inParameter4,
               const GGS_luint &  inParameter5,
               const GGS_luint &  inParameter6,
               const GGS_AC_task &  inParameter7,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_tasks info  ;
    info.mPriority = inParameter0 ;
    info.mOffset = inParameter1 ;
    info.mDeadline = inParameter2 ;
    info.mDurationMin = inParameter3 ;
    info.mDurationMax = inParameter4 ;
    info.mProcessor = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mTaskKind = inParameter7 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_AC_task   & outParameter7,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    outParameter7.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mPriority ;
    outParameter1 = node->mInfo.mOffset ;
    outParameter2 = node->mInfo.mDeadline ;
    outParameter3 = node->mInfo.mDurationMin ;
    outParameter4 = node->mInfo.mDurationMax ;
    outParameter5 = node->mInfo.mProcessor ;
    outParameter6 = node->mInfo.mPeriod ;
    outParameter7 = node->mInfo.mTaskKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_task   & outParameter7) {
  const char * kErrorMessage [] = {"the task '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  searchElement (inLexique,
                 kErrorMessage,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_task   & outParameter7) {
  const char * kErrorMessage [] = {"the task '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  searchElement (inLexique,
                 kErrorMessage,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 & outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_task & inParameter7) {
  const char * kErrorMessage [] = {"the task '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  insertElement (lexique_var_,
                 kErrorMessage,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL) ;
}

//---------------------------------------------------------------------------*

