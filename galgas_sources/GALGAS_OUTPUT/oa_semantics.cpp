//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'oa_semantics.cpp'                           *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                     february 2nd, 2005, at 20h21'6"                       *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "files/C_text_file_write.h"
#include "oa_semantics.h"


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'M_processor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_processor::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_processor & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_processor::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_processor *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_processor * info = (e_M_processor *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_processor::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_processor::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::constructor_empty (void) {
  GGS_M_processor result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_processor::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_processor info  ;
    info.mStep = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mStep ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_processor (C_lexique & inLexique,
                                GGS_M_processor & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_processor (C_lexique & lexique_var_,
                                GGS_M_processor & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_network'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_network::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_network & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_network::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_network *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_network * info = (e_M_network *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_network::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_network::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::constructor_empty (void) {
  GGS_M_network result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_network::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_bool&  inParameter0,
               const GGS_luint &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()) {
     insulateMap () ;
    e_M_network info  ;
    info.mCANnetwork = inParameter0 ;
    info.mScalingFactor = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_bool  * outParameter0,
               GGS_luint   * outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mCANnetwork ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mScalingFactor ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_network (C_lexique & inLexique,
                                GGS_M_network & ioMap,
                                const GGS_lstring & inKey,
                                GGS_bool  * outParameter0,
                                GGS_luint   * outParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_network (C_lexique & lexique_var_,
                                GGS_M_network & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_luint & inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the processor '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_canMessage'                     *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_canMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (void) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (const GGS_AC_canMessage & inOperand) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
~GGS_AC_canMessage (void) {
  macroDetachPointer (mPointer, cPtr_AC_canMessage) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage::
operator = (const GGS_AC_canMessage & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_canMessage::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage::
operator = (cPtr_AC_canMessage * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (cPtr_AC_canMessage * inSource) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_canMessage * GGS_AC_canMessage
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_canMessage) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_canIndependantMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_C_canIndependantMessage::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canIndependantMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_canIndependantMessage * GGS_C_canIndependantMessage::
    constructor_new () {
    cPtr_C_canIndependantMessage * ptr_ = (cPtr_C_canIndependantMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_canIndependantMessage ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_canMessageFromMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromMessage::cPtr_C_canMessageFromMessage (const GGS_luint & argument_0)
:mMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_canMessageFromMessage::isBuilt (void) const {
  return mMessageIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canMessageFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_canMessageFromMessage * GGS_C_canMessageFromMessage::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_C_canMessageFromMessage * ptr_ = (cPtr_C_canMessageFromMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_canMessageFromMessage (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_canMessageFromTask'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromTask::cPtr_C_canMessageFromTask (const GGS_luint & argument_0)
:mTaskIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_canMessageFromTask::isBuilt (void) const {
  return mTaskIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_canMessageFromTask'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_canMessageFromTask * GGS_C_canMessageFromTask::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_C_canMessageFromTask * ptr_ = (cPtr_C_canMessageFromTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_canMessageFromTask (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_messages'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_messages::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_messages & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_messages::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_messages *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_messages * info = (e_M_messages *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_messages::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_messages::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::constructor_empty (void) {
  GGS_M_messages result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_messages::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               const GGS_luint &  inParameter1,
               const GGS_luint &  inParameter2,
               const GGS_luint &  inParameter3,
               const GGS_luint &  inParameter4,
               const GGS_luint &  inParameter5,
               const GGS_luint &  inParameter6,
               const GGS_AC_canMessage &  inParameter7,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()
                 && inParameter2.isBuilt ()
                 && inParameter3.isBuilt ()
                 && inParameter4.isBuilt ()
                 && inParameter5.isBuilt ()
                 && inParameter6.isBuilt ()
                 && inParameter7.isBuilt ()) {
     insulateMap () ;
    e_M_messages info  ;
    info.mClass = inParameter0 ;
    info.mNetworkIndex = inParameter1 ;
    info.mBytesCount = inParameter2 ;
    info.mPriority = inParameter3 ;
    info.mOffset = inParameter4 ;
    info.mDeadline = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mMessageKind = inParameter7 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint   * outParameter0,
               GGS_luint   * outParameter1,
               GGS_luint   * outParameter2,
               GGS_luint   * outParameter3,
               GGS_luint   * outParameter4,
               GGS_luint   * outParameter5,
               GGS_luint   * outParameter6,
               GGS_AC_canMessage   * outParameter7,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outParameter2 != NULL) {
      outParameter2->drop_operation () ;
    }
    if (outParameter3 != NULL) {
      outParameter3->drop_operation () ;
    }
    if (outParameter4 != NULL) {
      outParameter4->drop_operation () ;
    }
    if (outParameter5 != NULL) {
      outParameter5->drop_operation () ;
    }
    if (outParameter6 != NULL) {
      outParameter6->drop_operation () ;
    }
    if (outParameter7 != NULL) {
      outParameter7->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mClass ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mNetworkIndex ;
    }
    if (outParameter2 != NULL) {
      * outParameter2 = node->mInfo.mBytesCount ;
    }
    if (outParameter3 != NULL) {
      * outParameter3 = node->mInfo.mPriority ;
    }
    if (outParameter4 != NULL) {
      * outParameter4 = node->mInfo.mOffset ;
    }
    if (outParameter5 != NULL) {
      * outParameter5 = node->mInfo.mDeadline ;
    }
    if (outParameter6 != NULL) {
      * outParameter6 = node->mInfo.mPeriod ;
    }
    if (outParameter7 != NULL) {
      * outParameter7 = node->mInfo.mMessageKind ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_messages (C_lexique & inLexique,
                                GGS_M_messages & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint   * outParameter0,
                                GGS_luint   * outParameter1,
                                GGS_luint   * outParameter2,
                                GGS_luint   * outParameter3,
                                GGS_luint   * outParameter4,
                                GGS_luint   * outParameter5,
                                GGS_luint   * outParameter6,
                                GGS_AC_canMessage   * outParameter7,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the CAN message '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outParameter2,
                       outParameter3,
                       outParameter4,
                       outParameter5,
                       outParameter6,
                       outParameter7,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_messages (C_lexique & lexique_var_,
                                GGS_M_messages & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_canMessage & inParameter7,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the CAN message '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       inParameter2,
                       inParameter3,
                       inParameter4,
                       inParameter5,
                       inParameter6,
                       inParameter7,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      abstract class 'cPtr_AC_task'                        *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_task'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (void) {
  mPointer = (cPtr_AC_task *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (const GGS_AC_task & inOperand) {
  mPointer = (cPtr_AC_task *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
~GGS_AC_task (void) {
  macroDetachPointer (mPointer, cPtr_AC_task) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task::
operator = (const GGS_AC_task & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_task::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task::
operator = (cPtr_AC_task * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (cPtr_AC_task * inSource) {
  mPointer = (cPtr_AC_task *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_task * GGS_AC_task
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_task) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_independantTask'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_C_independantTask::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_independantTask'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_independantTask * GGS_C_independantTask::
    constructor_new () {
    cPtr_C_independantTask * ptr_ = (cPtr_C_independantTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_independantTask ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_taskDependsFromTask'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromTask::cPtr_C_taskDependsFromTask (const GGS_luint & argument_0,
                                const GGS_luint & argument_1)
:mTask (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_taskDependsFromTask::isBuilt (void) const {
  return mTask.isBuilt () &&
       mEvery.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_taskDependsFromTask'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_taskDependsFromTask * GGS_C_taskDependsFromTask::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
    cPtr_C_taskDependsFromTask * ptr_ = (cPtr_C_taskDependsFromTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_taskDependsFromTask (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_taskDependsFromMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromMessage::cPtr_C_taskDependsFromMessage (const GGS_luint & argument_0,
                                const GGS_luint & argument_1)
:mMessage (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_taskDependsFromMessage::isBuilt (void) const {
  return mMessage.isBuilt () &&
       mEvery.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_taskDependsFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_taskDependsFromMessage * GGS_C_taskDependsFromMessage::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
    cPtr_C_taskDependsFromMessage * ptr_ = (cPtr_C_taskDependsFromMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_taskDependsFromMessage (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'M_tasks'                             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_tasks::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_tasks & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_tasks::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_tasks *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_tasks * info = (e_M_tasks *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_tasks::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_tasks::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::constructor_empty (void) {
  GGS_M_tasks result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_tasks::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               const GGS_luint &  inParameter1,
               const GGS_luint &  inParameter2,
               const GGS_luint &  inParameter3,
               const GGS_luint &  inParameter4,
               const GGS_luint &  inParameter5,
               const GGS_luint &  inParameter6,
               const GGS_AC_task &  inParameter7,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()
                 && inParameter2.isBuilt ()
                 && inParameter3.isBuilt ()
                 && inParameter4.isBuilt ()
                 && inParameter5.isBuilt ()
                 && inParameter6.isBuilt ()
                 && inParameter7.isBuilt ()) {
     insulateMap () ;
    e_M_tasks info  ;
    info.mPriority = inParameter0 ;
    info.mOffset = inParameter1 ;
    info.mDeadline = inParameter2 ;
    info.mDurationMin = inParameter3 ;
    info.mDurationMax = inParameter4 ;
    info.mProcessor = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mTaskKind = inParameter7 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint   * outParameter0,
               GGS_luint   * outParameter1,
               GGS_luint   * outParameter2,
               GGS_luint   * outParameter3,
               GGS_luint   * outParameter4,
               GGS_luint   * outParameter5,
               GGS_luint   * outParameter6,
               GGS_AC_task   * outParameter7,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outParameter2 != NULL) {
      outParameter2->drop_operation () ;
    }
    if (outParameter3 != NULL) {
      outParameter3->drop_operation () ;
    }
    if (outParameter4 != NULL) {
      outParameter4->drop_operation () ;
    }
    if (outParameter5 != NULL) {
      outParameter5->drop_operation () ;
    }
    if (outParameter6 != NULL) {
      outParameter6->drop_operation () ;
    }
    if (outParameter7 != NULL) {
      outParameter7->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mPriority ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mOffset ;
    }
    if (outParameter2 != NULL) {
      * outParameter2 = node->mInfo.mDeadline ;
    }
    if (outParameter3 != NULL) {
      * outParameter3 = node->mInfo.mDurationMin ;
    }
    if (outParameter4 != NULL) {
      * outParameter4 = node->mInfo.mDurationMax ;
    }
    if (outParameter5 != NULL) {
      * outParameter5 = node->mInfo.mProcessor ;
    }
    if (outParameter6 != NULL) {
      * outParameter6 = node->mInfo.mPeriod ;
    }
    if (outParameter7 != NULL) {
      * outParameter7 = node->mInfo.mTaskKind ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_tasks (C_lexique & inLexique,
                                GGS_M_tasks & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint   * outParameter0,
                                GGS_luint   * outParameter1,
                                GGS_luint   * outParameter2,
                                GGS_luint   * outParameter3,
                                GGS_luint   * outParameter4,
                                GGS_luint   * outParameter5,
                                GGS_luint   * outParameter6,
                                GGS_AC_task   * outParameter7,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the task '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outParameter2,
                       outParameter3,
                       outParameter4,
                       outParameter5,
                       outParameter6,
                       outParameter7,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_tasks (C_lexique & lexique_var_,
                                GGS_M_tasks & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_task & inParameter7,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the task '",
                                   "",
                                   "' has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       inParameter2,
                       inParameter3,
                       inParameter4,
                       inParameter5,
                       inParameter6,
                       inParameter7,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

