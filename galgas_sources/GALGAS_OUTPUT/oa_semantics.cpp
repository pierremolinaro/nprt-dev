//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'oa_semantics.cpp'                           *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 5th, 2006, at 22h55'17"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "oa_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "oa_parser.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'M_processor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_processor::
elementOf_GGS_M_processor (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_processor & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_processor::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mStep.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_processor::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_processor *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_processor * info = (e_M_processor *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_processor result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_processor info  ;
    info.mStep = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStep ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the processor '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the processor '%K' is not declared",
                 inKey,
                 outParameter0,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the processor '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_processor & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_processor result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_processor result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_processor::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_processor " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_network'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_network::
elementOf_GGS_M_network (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_network & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_network::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mCANnetwork.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mScalingFactor.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_network::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_network *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_network * info = (e_M_network *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_network result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_bool&  inParameter0,
               const GGS_luint &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_network info  ;
    info.mCANnetwork = inParameter0 ;
    info.mScalingFactor = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mCANnetwork ;
    outParameter1 = node->mInfo.mScalingFactor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_luint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the processor '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_bool  & outParameter0,
                                GGS_luint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the processor '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_luint & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the processor '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_network & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_network result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_network result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_network::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_network " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_canMessage'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_canMessage::
cPtr_AC_canMessage (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_canMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (void) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (const GGS_AC_canMessage & inOperand) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
~GGS_AC_canMessage (void) {
  macroDetachPointer (mPointer, cPtr_AC_canMessage) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage::
operator = (const GGS_AC_canMessage & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage::
operator = (cPtr_AC_canMessage * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (cPtr_AC_canMessage * inSource) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_canMessage * GGS_AC_canMessage
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_canMessage
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_canMessage) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_canMessage
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_canMessage" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_canIndependantMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canIndependantMessage::cPtr_C_canIndependantMessage (LOCATION_ARGS)
:cPtr_AC_canMessage (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_C_canIndependantMessage::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_canIndependantMessage:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canIndependantMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canIndependantMessage * GGS_C_canIndependantMessage::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_C_canIndependantMessage * ptr_ = (cPtr_C_canIndependantMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_canIndependantMessage (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_canMessageFromMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromMessage::cPtr_C_canMessageFromMessage (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_canMessage (THERE),
mMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_canMessageFromMessage::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_canMessageFromMessage:" ;
mMessageIndex.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canMessageFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canMessageFromMessage * GGS_C_canMessageFromMessage::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_canMessageFromMessage * ptr_ = (cPtr_C_canMessageFromMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_canMessageFromMessage (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_canMessageFromTask'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromTask::cPtr_C_canMessageFromTask (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_canMessage (THERE),
mTaskIndex (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_canMessageFromTask::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_canMessageFromTask:" ;
mTaskIndex.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_canMessageFromTask'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canMessageFromTask * GGS_C_canMessageFromTask::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_canMessageFromTask * ptr_ = (cPtr_C_canMessageFromTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_canMessageFromTask (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_messages'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_messages::
elementOf_GGS_M_messages (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_messages & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_messages::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mClass.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mNetworkIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mBytesCount.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mPriority.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mOffset.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mDeadline.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mPeriod.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mMessageKind.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_messages::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_messages *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_messages * info = (e_M_messages *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_messages result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               const GGS_luint &  inParameter1,
               const GGS_luint &  inParameter2,
               const GGS_luint &  inParameter3,
               const GGS_luint &  inParameter4,
               const GGS_luint &  inParameter5,
               const GGS_luint &  inParameter6,
               const GGS_AC_canMessage &  inParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inParameter7.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_messages info  ;
    info.mClass = inParameter0 ;
    info.mNetworkIndex = inParameter1 ;
    info.mBytesCount = inParameter2 ;
    info.mPriority = inParameter3 ;
    info.mOffset = inParameter4 ;
    info.mDeadline = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mMessageKind = inParameter7 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_AC_canMessage   & outParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    outParameter7.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mClass ;
    outParameter1 = node->mInfo.mNetworkIndex ;
    outParameter2 = node->mInfo.mBytesCount ;
    outParameter3 = node->mInfo.mPriority ;
    outParameter4 = node->mInfo.mOffset ;
    outParameter5 = node->mInfo.mDeadline ;
    outParameter6 = node->mInfo.mPeriod ;
    outParameter7 = node->mInfo.mMessageKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_canMessage   & outParameter7 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the CAN message '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_canMessage   & outParameter7 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the CAN message '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_canMessage & inParameter7 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the CAN message '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_messages & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_messages result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_messages result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_messages::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_messages " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      abstract class 'cPtr_AC_task'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_task::
cPtr_AC_task (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_task'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (void) {
  mPointer = (cPtr_AC_task *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (const GGS_AC_task & inOperand) {
  mPointer = (cPtr_AC_task *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
~GGS_AC_task (void) {
  macroDetachPointer (mPointer, cPtr_AC_task) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task::
operator = (const GGS_AC_task & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task::
operator = (cPtr_AC_task * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (cPtr_AC_task * inSource) {
  mPointer = (cPtr_AC_task *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_task * GGS_AC_task
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_task
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_task) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_task
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_task" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_independantTask'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_independantTask::cPtr_C_independantTask (LOCATION_ARGS)
:cPtr_AC_task (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_C_independantTask::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_independantTask:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_independantTask'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_independantTask * GGS_C_independantTask::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_C_independantTask * ptr_ = (cPtr_C_independantTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_independantTask (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_taskDependsFromTask'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromTask::cPtr_C_taskDependsFromTask (const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_task (THERE),
mTask (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_taskDependsFromTask::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_taskDependsFromTask:" ;
mTask.reader_description  (_inLexique COMMA_THERE) ;
mEvery.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_taskDependsFromTask'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_taskDependsFromTask * GGS_C_taskDependsFromTask::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_taskDependsFromTask * ptr_ = (cPtr_C_taskDependsFromTask *) NULL ;
    macroMyNew (ptr_, cPtr_C_taskDependsFromTask (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_taskDependsFromMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromMessage::cPtr_C_taskDependsFromMessage (const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_task (THERE),
mMessage (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_taskDependsFromMessage::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_taskDependsFromMessage:" ;
mMessage.reader_description  (_inLexique COMMA_THERE) ;
mEvery.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_taskDependsFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_taskDependsFromMessage * GGS_C_taskDependsFromMessage::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_taskDependsFromMessage * ptr_ = (cPtr_C_taskDependsFromMessage *) NULL ;
    macroMyNew (ptr_, cPtr_C_taskDependsFromMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'M_tasks'                             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_tasks::
elementOf_GGS_M_tasks (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_tasks & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_tasks::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mPriority.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mOffset.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mDeadline.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mDurationMin.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mDurationMax.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mProcessor.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mPeriod.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mTaskKind.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_tasks::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_tasks *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_tasks * info = (e_M_tasks *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_tasks result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               const GGS_luint &  inParameter1,
               const GGS_luint &  inParameter2,
               const GGS_luint &  inParameter3,
               const GGS_luint &  inParameter4,
               const GGS_luint &  inParameter5,
               const GGS_luint &  inParameter6,
               const GGS_AC_task &  inParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inParameter7.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_tasks info  ;
    info.mPriority = inParameter0 ;
    info.mOffset = inParameter1 ;
    info.mDeadline = inParameter2 ;
    info.mDurationMin = inParameter3 ;
    info.mDurationMax = inParameter4 ;
    info.mProcessor = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mTaskKind = inParameter7 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_AC_task   & outParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    outParameter7.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mPriority ;
    outParameter1 = node->mInfo.mOffset ;
    outParameter2 = node->mInfo.mDeadline ;
    outParameter3 = node->mInfo.mDurationMin ;
    outParameter4 = node->mInfo.mDurationMax ;
    outParameter5 = node->mInfo.mProcessor ;
    outParameter6 = node->mInfo.mPeriod ;
    outParameter7 = node->mInfo.mTaskKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_task   & outParameter7 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the task '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_task   & outParameter7 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the task '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_task & inParameter7 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the task '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_tasks & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_tasks result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_tasks result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_tasks::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_tasks " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

