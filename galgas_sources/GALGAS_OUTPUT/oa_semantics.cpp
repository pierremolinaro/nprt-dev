//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'oa_semantics.cpp'                           *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     november 9th, 2006, at 17h48'54"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "oa_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "oa_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map 'M_processor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_processor::
elementOf_GGS_M_processor (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_processor & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_processor::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mStep.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_processor::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_processor * _p = dynamic_cast <const elementOf_GGS_M_processor *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mStep == _p->mInfo.mStep).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_processor::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_processor *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_processor * info = (e_M_processor *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_processor result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

GGS_bool GGS_M_processor::
operator == (const GGS_M_processor & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_processor::
operator != (const GGS_M_processor & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void GGS_M_processor::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_processor info  ;
    info.mStep = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mStep ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_processor::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the processor '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the processor '%K' is not declared",
                 inKey,
                 outParameter0,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_processor::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the processor '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_processor & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_processor result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_processor GGS_M_processor::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_processor result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_processor::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_processor " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_network'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_network::
elementOf_GGS_M_network (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_network & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_network::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mCANnetwork.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mScalingFactor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_network::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_network * _p = dynamic_cast <const elementOf_GGS_M_network *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mCANnetwork == _p->mInfo.mCANnetwork).boolValue ()
           && (mInfo.mScalingFactor == _p->mInfo.mScalingFactor).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_network::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_network *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_network * info = (e_M_network *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_network result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

GGS_bool GGS_M_network::
operator == (const GGS_M_network & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_network::
operator != (const GGS_M_network & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void GGS_M_network::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_bool&  inParameter0,
               const GGS_luint &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_network info  ;
    info.mCANnetwork = inParameter0 ;
    info.mScalingFactor = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mCANnetwork ;
    outParameter1 = node->mInfo.mScalingFactor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_network::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_luint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the processor '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_bool  & outParameter0,
                                GGS_luint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the processor '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_network::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_luint & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the processor '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_network & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_network result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_network GGS_M_network::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_network result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_network::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_network " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_canMessage'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_canMessage::
cPtr_AC_canMessage (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_AC_canMessage::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_canMessage:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_canMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
GGS_AC_canMessage (const GGS_AC_canMessage & inOperand) {
  mPointer = (cPtr_AC_canMessage *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_canMessage::
~GGS_AC_canMessage (void) {
  macroDetachPointer (mPointer, cPtr_AC_canMessage) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_canMessage::
operator = (const GGS_AC_canMessage & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_canMessage * GGS_AC_canMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_canMessage::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_canMessage) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_canMessage::
operator == (const GGS_AC_canMessage & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_canMessage::
operator != (const GGS_AC_canMessage & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_canMessage::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_canMessage" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_canIndependantMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canIndependantMessage::cPtr_C_canIndependantMessage (LOCATION_ARGS)
:cPtr_AC_canMessage (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_canIndependantMessage::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canIndependantMessage::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@C_canIndependantMessage:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canIndependantMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage::
GGS_C_canIndependantMessage (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_canIndependantMessage GGS_C_canIndependantMessage::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_C_canIndependantMessage * _ptr = (cPtr_C_canIndependantMessage *) NULL ;
  macroMyNew (_ptr, cPtr_C_canIndependantMessage (THERE)) ;
  GGS_C_canIndependantMessage result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canIndependantMessage * GGS_C_canIndependantMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canIndependantMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_canIndependantMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_bool GGS_C_canIndependantMessage::
operator == (const GGS_C_canIndependantMessage & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer == inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_canIndependantMessage::
operator != (const GGS_C_canIndependantMessage & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer != inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_canIndependantMessage::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_canIndependantMessage" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_canMessageFromMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromMessage::cPtr_C_canMessageFromMessage (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_canMessage (THERE),
mMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_canMessageFromMessage::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_canMessageFromMessage * _p = dynamic_cast <const cPtr_C_canMessageFromMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMessageIndex == _p->mMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canMessageFromMessage::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_canMessageFromMessage:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mMessageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_canMessageFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage::
GGS_C_canMessageFromMessage (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromMessage GGS_C_canMessageFromMessage::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_canMessageFromMessage * _ptr = (cPtr_C_canMessageFromMessage *) NULL ;
  macroMyNew (_ptr, cPtr_C_canMessageFromMessage (argument_0 COMMA_THERE)) ;
  GGS_C_canMessageFromMessage result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_canMessageFromMessage::
reader_mMessageIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_canMessageFromMessage *) mPointer)->mMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canMessageFromMessage * GGS_C_canMessageFromMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_canMessageFromMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_bool GGS_C_canMessageFromMessage::
operator == (const GGS_C_canMessageFromMessage & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer == inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_canMessageFromMessage::
operator != (const GGS_C_canMessageFromMessage & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer != inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_canMessageFromMessage::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_canMessageFromMessage" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_canMessageFromTask'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_canMessageFromTask::cPtr_C_canMessageFromTask (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_canMessage (THERE),
mTaskIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_canMessageFromTask::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_canMessageFromTask * _p = dynamic_cast <const cPtr_C_canMessageFromTask *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTaskIndex == _p->mTaskIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_canMessageFromTask::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_canMessageFromTask:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mTaskIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_canMessageFromTask'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask::
GGS_C_canMessageFromTask (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_canMessageFromTask GGS_C_canMessageFromTask::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_canMessageFromTask * _ptr = (cPtr_C_canMessageFromTask *) NULL ;
  macroMyNew (_ptr, cPtr_C_canMessageFromTask (argument_0 COMMA_THERE)) ;
  GGS_C_canMessageFromTask result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_canMessageFromTask::
reader_mTaskIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_canMessageFromTask *) mPointer)->mTaskIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_canMessageFromTask * GGS_C_canMessageFromTask::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_canMessageFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_canMessageFromTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_bool GGS_C_canMessageFromTask::
operator == (const GGS_C_canMessageFromTask & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer == inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_canMessageFromTask::
operator != (const GGS_C_canMessageFromTask & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer != inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_canMessageFromTask::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_canMessageFromTask" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_messages'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_messages::
elementOf_GGS_M_messages (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_messages & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_messages::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mClass.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mNetworkIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mBytesCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mPriority.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDeadline.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mPeriod.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessageKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_messages::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_messages * _p = dynamic_cast <const elementOf_GGS_M_messages *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mClass == _p->mInfo.mClass).boolValue ()
           && (mInfo.mNetworkIndex == _p->mInfo.mNetworkIndex).boolValue ()
           && (mInfo.mBytesCount == _p->mInfo.mBytesCount).boolValue ()
           && (mInfo.mPriority == _p->mInfo.mPriority).boolValue ()
           && (mInfo.mOffset == _p->mInfo.mOffset).boolValue ()
           && (mInfo.mDeadline == _p->mInfo.mDeadline).boolValue ()
           && (mInfo.mPeriod == _p->mInfo.mPeriod).boolValue ()
           && (mInfo.mMessageKind == _p->mInfo.mMessageKind).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_messages::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_messages *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_messages * info = (e_M_messages *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_messages result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

GGS_bool GGS_M_messages::
operator == (const GGS_M_messages & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_messages::
operator != (const GGS_M_messages & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void GGS_M_messages::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               const GGS_luint &  inParameter1,
               const GGS_luint &  inParameter2,
               const GGS_luint &  inParameter3,
               const GGS_luint &  inParameter4,
               const GGS_luint &  inParameter5,
               const GGS_luint &  inParameter6,
               const GGS_AC_canMessage &  inParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inParameter6._isBuilt ()
   && inParameter7._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_messages info  ;
    info.mClass = inParameter0 ;
    info.mNetworkIndex = inParameter1 ;
    info.mBytesCount = inParameter2 ;
    info.mPriority = inParameter3 ;
    info.mOffset = inParameter4 ;
    info.mDeadline = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mMessageKind = inParameter7 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_AC_canMessage   & outParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    outParameter4._drop_operation () ;
    outParameter5._drop_operation () ;
    outParameter6._drop_operation () ;
    outParameter7._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mClass ;
    outParameter1 = node->mInfo.mNetworkIndex ;
    outParameter2 = node->mInfo.mBytesCount ;
    outParameter3 = node->mInfo.mPriority ;
    outParameter4 = node->mInfo.mOffset ;
    outParameter5 = node->mInfo.mDeadline ;
    outParameter6 = node->mInfo.mPeriod ;
    outParameter7 = node->mInfo.mMessageKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_messages::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_canMessage   & outParameter7 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the CAN message '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_canMessage   & outParameter7 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the CAN message '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_messages::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_canMessage & inParameter7 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the CAN message '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_messages & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_messages result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_messages GGS_M_messages::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_messages result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_messages::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_messages " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      abstract class 'cPtr_AC_task'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_task::
cPtr_AC_task (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_AC_task::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_task:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_task'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
GGS_AC_task (const GGS_AC_task & inOperand) {
  mPointer = (cPtr_AC_task *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_task::
~GGS_AC_task (void) {
  macroDetachPointer (mPointer, cPtr_AC_task) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_task::
operator = (const GGS_AC_task & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_task * GGS_AC_task::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_task::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_task) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_task::
operator == (const GGS_AC_task & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_task::
operator != (const GGS_AC_task & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_task::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_task" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_independantTask'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_independantTask::cPtr_C_independantTask (LOCATION_ARGS)
:cPtr_AC_task (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_independantTask::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_independantTask::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << " ->@C_independantTask:" ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_independantTask'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_independantTask::
GGS_C_independantTask (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_independantTask GGS_C_independantTask::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_C_independantTask * _ptr = (cPtr_C_independantTask *) NULL ;
  macroMyNew (_ptr, cPtr_C_independantTask (THERE)) ;
  GGS_C_independantTask result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_independantTask * GGS_C_independantTask::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_independantTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_independantTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_bool GGS_C_independantTask::
operator == (const GGS_C_independantTask & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer == inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_independantTask::
operator != (const GGS_C_independantTask & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer != inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_independantTask::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_independantTask" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_taskDependsFromTask'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromTask::cPtr_C_taskDependsFromTask (const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_task (THERE),
mTask (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_taskDependsFromTask::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_taskDependsFromTask * _p = dynamic_cast <const cPtr_C_taskDependsFromTask *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTask == _p->mTask).boolValue ()
         && (mEvery == _p->mEvery).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_taskDependsFromTask::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_taskDependsFromTask:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mTask.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mEvery.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_taskDependsFromTask'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask::
GGS_C_taskDependsFromTask (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromTask GGS_C_taskDependsFromTask::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_taskDependsFromTask * _ptr = (cPtr_C_taskDependsFromTask *) NULL ;
  macroMyNew (_ptr, cPtr_C_taskDependsFromTask (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_taskDependsFromTask result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromTask::
reader_mTask (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromTask *) mPointer)->mTask ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromTask::
reader_mEvery (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromTask *) mPointer)->mEvery ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_taskDependsFromTask * GGS_C_taskDependsFromTask::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromTask *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_taskDependsFromTask *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_bool GGS_C_taskDependsFromTask::
operator == (const GGS_C_taskDependsFromTask & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer == inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_taskDependsFromTask::
operator != (const GGS_C_taskDependsFromTask & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer != inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_taskDependsFromTask::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_taskDependsFromTask" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_taskDependsFromMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_taskDependsFromMessage::cPtr_C_taskDependsFromMessage (const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_task (THERE),
mMessage (argument_0),
mEvery (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_taskDependsFromMessage::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_taskDependsFromMessage * _p = dynamic_cast <const cPtr_C_taskDependsFromMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMessage == _p->mMessage).boolValue ()
         && (mEvery == _p->mEvery).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_taskDependsFromMessage::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_taskDependsFromMessage:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mEvery.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_taskDependsFromMessage'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage::
GGS_C_taskDependsFromMessage (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_taskDependsFromMessage GGS_C_taskDependsFromMessage::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_taskDependsFromMessage * _ptr = (cPtr_C_taskDependsFromMessage *) NULL ;
  macroMyNew (_ptr, cPtr_C_taskDependsFromMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_taskDependsFromMessage result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromMessage::
reader_mMessage (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromMessage *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_taskDependsFromMessage::
reader_mEvery (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_taskDependsFromMessage *) mPointer)->mEvery ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_taskDependsFromMessage * GGS_C_taskDependsFromMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_taskDependsFromMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_taskDependsFromMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_bool GGS_C_taskDependsFromMessage::
operator == (const GGS_C_taskDependsFromMessage & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer == inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_taskDependsFromMessage::
operator != (const GGS_C_taskDependsFromMessage & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), mPointer != inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_taskDependsFromMessage::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_taskDependsFromMessage" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'M_tasks'                             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_tasks::
elementOf_GGS_M_tasks (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_tasks & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_tasks::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mPriority.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDeadline.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDurationMin.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDurationMax.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mProcessor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mPeriod.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTaskKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_tasks::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_tasks * _p = dynamic_cast <const elementOf_GGS_M_tasks *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mPriority == _p->mInfo.mPriority).boolValue ()
           && (mInfo.mOffset == _p->mInfo.mOffset).boolValue ()
           && (mInfo.mDeadline == _p->mInfo.mDeadline).boolValue ()
           && (mInfo.mDurationMin == _p->mInfo.mDurationMin).boolValue ()
           && (mInfo.mDurationMax == _p->mInfo.mDurationMax).boolValue ()
           && (mInfo.mProcessor == _p->mInfo.mProcessor).boolValue ()
           && (mInfo.mPeriod == _p->mInfo.mPeriod).boolValue ()
           && (mInfo.mTaskKind == _p->mInfo.mTaskKind).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_tasks::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_tasks *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_tasks * info = (e_M_tasks *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_tasks result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

GGS_bool GGS_M_tasks::
operator == (const GGS_M_tasks & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_tasks::
operator != (const GGS_M_tasks & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void GGS_M_tasks::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_luint &  inParameter0,
               const GGS_luint &  inParameter1,
               const GGS_luint &  inParameter2,
               const GGS_luint &  inParameter3,
               const GGS_luint &  inParameter4,
               const GGS_luint &  inParameter5,
               const GGS_luint &  inParameter6,
               const GGS_AC_task &  inParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inParameter6._isBuilt ()
   && inParameter7._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_tasks info  ;
    info.mPriority = inParameter0 ;
    info.mOffset = inParameter1 ;
    info.mDeadline = inParameter2 ;
    info.mDurationMin = inParameter3 ;
    info.mDurationMax = inParameter4 ;
    info.mProcessor = inParameter5 ;
    info.mPeriod = inParameter6 ;
    info.mTaskKind = inParameter7 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint   & outParameter0,
               GGS_luint   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint   & outParameter3,
               GGS_luint   & outParameter4,
               GGS_luint   & outParameter5,
               GGS_luint   & outParameter6,
               GGS_AC_task   & outParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    outParameter4._drop_operation () ;
    outParameter5._drop_operation () ;
    outParameter6._drop_operation () ;
    outParameter7._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mPriority ;
    outParameter1 = node->mInfo.mOffset ;
    outParameter2 = node->mInfo.mDeadline ;
    outParameter3 = node->mInfo.mDurationMin ;
    outParameter4 = node->mInfo.mDurationMax ;
    outParameter5 = node->mInfo.mProcessor ;
    outParameter6 = node->mInfo.mPeriod ;
    outParameter7 = node->mInfo.mTaskKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_task   & outParameter7 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the task '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_luint   & outParameter0,
                                GGS_luint   & outParameter1,
                                GGS_luint   & outParameter2,
                                GGS_luint   & outParameter3,
                                GGS_luint   & outParameter4,
                                GGS_luint   & outParameter5,
                                GGS_luint   & outParameter6,
                                GGS_AC_task   & outParameter7 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the task '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_tasks::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_luint & inParameter0,
                                const GGS_luint & inParameter1,
                                const GGS_luint & inParameter2,
                                const GGS_luint & inParameter3,
                                const GGS_luint & inParameter4,
                                const GGS_luint & inParameter5,
                                const GGS_luint & inParameter6,
                                const GGS_AC_task & inParameter7 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the task '%K' has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_tasks & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_tasks result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_tasks GGS_M_tasks::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_tasks result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_tasks::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_tasks " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

